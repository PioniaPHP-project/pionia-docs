[
  { "content": "MoonLight is a rather new architecture that is based on the commonly used architectures of gRPC, MVC(Model View Controller), Micro-Services and Monolothic. It picks the best of all these architectures and combines them to create a new architecture that is more efficient and scalable.\nThe MoonLight paradigm Below are the new conventions that MoonLight architecture brings to the table:\nArchitecture Overview\nThe car scenario! \u0026ndash; 1\nImagine a scenario of a car, the car can have passengers and multiple passengers. The job of the driver is to controll the rest of the car, and the passengers to behave themselves and not interfere with the driver. The driver has one steering wheel in the entire car. Some cars may have a conductor who is responsible for the passengers instead of the driver. This helps the driver to focus on the road and not the passengers.\nThe traffic scenario! \u0026ndash; 2\nBased on the scenario above, the driver is stopped by the traffic police man, the polica man moves to the driver\u0026rsquo;s side and not the passengers side. The police man looks through the driver\u0026rsquo;s window and checks if there are any issues with the passengers. He asks the first passenger to pass over their id, the passenger forwards the id to the driver who then hands it over to the police. He checks and gives it to the driver who then hands it over to the passenger.\nNOTE Remember the above scenarios as we dive into the MoonLight architecture\n1. Single API endpoint/route In the moonlight, all requests target the same endpoint. This is to ensure that the application is scalable and easy to maintain. This also makes it easier to debug and monitor the application.\nAssuming the application is running on http://localhost:3000, all requests will be made to http://localhost:3000/api/v1/. This is the only endpoint that is exposed to the outside world.\nOn top of other advantages, now frontend devs don\u0026rsquo;t have to worry about the base URL of the API. They can just make requests to the /api/v1/ endpoint and the application will handle the rest.\nPoint To Ponder!\nThis is our drivers window in the car scenario.\nFor anyone to interact with the application, they must go through this endpoint only.\n2. POST Requests only All requests under moonlight architecture are made using the http method of POST only. This is to ensure that the requests are secure and the data is not exposed in the server logs or in the URL. This also makes it easier to debug and monitor the application. Read more on security.\n3. Single Request Format In Moonlight architecture, all requests are made in a similar format. This makes it easier to understand and debug the requests. Requests can either be of type JSON or form-data.\nEvery request must define the SERVICE and ACTION to execute in the request body plus the rest of the payload as required by the service.\nPOST http://localhost:3000/api/v1/\r{ \u0026#34;SERVICE\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;get_user_by_profile\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;@1233232\u0026#34; }\rThe SERVICE and ACTION are required in every request. The rest of the payload is dependent on the service and action being executed.\nPoint To Ponder!\nThis architecture, if to be well implemented must follow the Object Oriented Programming paradigm. With this, services should/must be classes or interfaces(golang) that combine together related business logic like AuthenticationService, ProductService, OrderService etc.\nAnd Actions should be methods in these classes like login, register in the AuthenticationService class.\n4. Single Response Format This architecture also calls for a single response format. This makes it way easier to understand and debug the responses. The response format is as follows:\nResponse\r{ \u0026#34;statusCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Some cool message here or null\u0026#34;, \u0026#34;returnData\u0026#34;: \u0026#34;the data you\u0026#39;re sending to the frontend\u0026#34;, \u0026#34;extraData\u0026#34;: \u0026#34;any extra data you want to send to the frontend\u0026#34; }\rWith statusCode, it implies that the developer/business can define their own custom status codes. However, by convention, a status code of 0 implies success and is recommended to be kept for the same.\n5. HTTP 200 OK for all. All requests in this architecture that reach the application server should/must return an http status of 200 OK. The only special case is 502 Gateway Error which is returned when the application server is down or unreachable.\nPoint To Ponder!\nThink about it, the application server actually handled your request so whether the request raised an exception or successfully executed, the server actually handled. And that\u0026rsquo;s what we are actually looking for.\nRemember the traffic scenario!\nEvery time our police man poses a question, he expects an answer. If the driver doesn\u0026rsquo;t have an answer, he should say so(which is also an answer) and not just keep quiet.\n6. Single Controller Per Application. In this architecture, there is only one controller that handles all the requests. This controller is responsible for routing the requests to the appropriate service and action. This makes it easier to maintain and debug the application. This must be one per application.\nTo achieve api versioning, this controller can have multiple actions each pointing to a different version switch of the application. Each action can then route the request to the appropriate service switch.\nThis point is where the app should handle all exceptions that might be raised by the services and then return a 200 OK response with the appropriate message from the exception raised.\nExample using php.\nController\rclass ApiController extends Controller { public function v1() { try { // point to the service switch for version one } catch (\\Exception $e) { // handle the exception here } } public function v2() { try { // point to the service switch for version two } catch (\\Exception $e) { // handle the exception here } } } \u0026lt;?php\rNo logic should be in the controller, it should only be responsible for routing the requests to the appropriate switch.\nFor Pionia Framework, this is not required at all, since the framework handles this for you internally!\nPoint To Ponder!\nThis is the driver in the car scenario. The driver is responsible with handling all the police man\u0026rsquo;s questions and mapping them to the appropriate passenger.\n7. Single Service Switch Per API Version. In this architecture, there should only be one service switch that handles all the requests for a particular version of the application. This service switch is responsible reading the SERVICE in the request and call the responsible service passing it the action(ACTION) and the rest of the payload.\nThe service switch is just a convention to make our controller clean and easy to maintain. It is not a must to have it, but it is recommended. Otherwise, the switching logic would be handled in the controller action responsible for the version.\nPoint To Ponder!\nThis is the conductor in the car scenario. However much the driver can do everything the conductor can do, the conductor is there to reduce work load on the driver.\nThis implies that the driver focuses on the road and the conductor focuses on the passengers.\nThe controller focuses on mapping the requests, the service switch focuses on mapping the services and actions.\n8. Services and Actions In MoonLight architecture, services are classes or interfaces that combine related business logic. For example, AuthenticationService, ProductService, OrderService etc.\nActions are methods in these classes like login, register in the AuthenticationService class.\nPoint To Ponder!\nThis is the passenger in the car scenario. The passenger is responsible for their own luggage and reaching their destination. They are also responsible with fulfilling the driver\u0026rsquo;s requests.\nRemember, the driver asks the passenger for the id, the passenger passes it over to the driver! Passing the id is the passenger\u0026rsquo;s responsibility(action).\n9. Database and Querying In moonlight architecture, querying the database is highly recommended over using an ORM. This is because querying the database directly is faster and more efficient than using an ORM. Also, querying the database directly gives the developer more control over the queries and the data being returned.\nAll ORMs used in the Moonlight should not map resultsets to models. They should return the resultset as is.\nThis removes the unnecessary overhead of mapping the resultset to models(model hydration) and makes the application faster and more efficient.\n10. Separation of Concerns In this architecture, the backend is meant to support, command and act as a single source of truth for the frontend. This implies that the architecture requires implementers to implement the frontend and backend separately.\nHowever, this does not discourage serving the two together in production. Frameworks like Spring boot give you the ability to serve your entire frontend under your backend. This is highly encouraged. But Moonlight discourages writing of Frontend logic using the backend specific tools like PHP, Python and others.\nDevelopers should sorely harness the existence of the frontend tools to write re-usable, modularised and maintainable frontend code.\nThis way every tool will be maximised to its full potential.\nAdvantages of MoonLight Architecture Scalability :- Since adding new services and actions is easy, the application can be scaled easily. Maintainability :- Small codebase and single-logic services make it easy to maintain the application. Even new developers can easily understand the codebase. Security :- Since all requests are made using POST, the data is secure and not exposed in the Logs. Also, action level authentication and authorization makes it easy to secure the application at lower levels. High Performance :- Architecture stresses on querying the database directly and not using ORMs. This makes the application faster and more efficient. Developer Performance:- Since the architecture is simple and easy to understand, developers can roll out new features quickly without having to write a lot of boilerplate code. Easy Debugging :- Since all requests and responses are made in a similar format, it is easy to debug the application. Also, the single endpoint makes it easy to monitor the application. Frontend Integration :- One endpoint for all requests, one request format, one response format makes it easy for frontend devs to integrate the api. Disadvantages of MoonLight Architecture Some languages may not support switching between form-data and json requests. This might dictate all uploads to be base64 encoded. Moonlight is only suitable for APIs and not for fullstack applications. The architecture being new, there might be a learning curve for new developers and a small community to get help from. The community is growing and we are looking forward to having you on board.\n", "date": "2024-05-24", "id": 0, "permalink": "/moonlight/introduction-to-moonlight-architecture/", "summary": "MoonLight is a rather new architecture that is based on the commonly used architectures of gRPC, MVC(Model View Controller), Micro-Services and Monolothic.", "tags": [], "title": "Introduction to MoonLight Architecture" },
  { "content": "Introdution All requests sent to the server over https get encrypted and decrypted on the web server level. This ensures that attacks like man-in-the-middle are mitigated. This applies for all requests sent to the server whether via GET, POST, PUT, DELETE or any other method. On the server level, every request is logged. These logs omit the request body and only log domain, path, query params and headers. This ensures that the data is secure and not exposed in the URL.\nWe need this logging for debugging purposes, therefore, we might not choose to turn it off.\nExample below shows how the logs are stored in the server:\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;domain\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/api/v1/user\u0026#34;, \u0026#34;query\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34; }, \u0026#34;headers\u0026#34;: { \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34; } } This is where we have our first problem that we need to address. The query params are logged in the web server level. This is a security risk.\nHowever much this is is a rare case, imagine logging in via a GET request as below:\nhttps://example.com/api/v1/login?username=example\u0026amp;password=example\rThe parameters username and password are logged in the web server level in the raw format. This implies that, however much the passwords are encrypted in the database, they are exposed in the logs. Any malicious user with access to the logs can easily get the password and username.\nAs a result, the architecture encourages to perform all requests over POST. This is because POST requests\u0026rsquo; body is not logged in the web server level. This ensures that the data is secure.\nThis is a supplement to the single endpoit approach of MoonLight architecture.\nHTTP level security - POST Requests only With the above in mind, the architecture encourages to perform all requests over POST. This is because POST requests\u0026rsquo; body is not logged in the web server level. This ensures that the data is secure.\nSample moonlight request:\n{ \u0026#34;domain\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/api/v1/\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;body\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;example\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;example\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;login\u0026#34;, \u0026#34;service\u0026#34;: \u0026#34;auth\u0026#34;, } }\rThe above request is secure as the body is not logged in the web server level. This removes the only security risk that ssl encryption does not cover.\nAction Level Security Unlike most architectures, in moonlight, securing actions happens at the action level. This means that requests are let through whether authenticated or not. The action itself determines whether the request is authenticated or not.\nIf an action say, addCart requires a certain permission, the action itself mentions it. Therefore, actions are not protected globally but rather internally(on the method level).\nExample below shows how an action can be protected in pionia:\nclass TodoService extends BaseRestService { // your other actions here public function getTodo() { $this-\u0026gt;can(\u0026#39;view-todo\u0026#39;); // user must have the permission to view todo // your action here } }\rIn the above example, the action getTodo requires the user to have the permission view-todo. If the user does not have the permission, the action will not be executed. As observed, the action itself determines whether the request is authenticated or not.\n", "date": "2024-05-24", "id": 1, "permalink": "/moonlight/security-in-moonlight/", "summary": "All requests sent to the server get encrypted and decrypted on the web server level. This ensures that the data is secure and not exposed in the URL. However, all query params are logged in the web server level, the architecture encourages to perform all requests over POST.", "tags": [], "title": "Security in moonlight" },
  { "content": "Introdution In Moonlight, every switch is directly associated to a version of your api. This means that, to get another version of the api, you just need to roll out a new service including only those services that are going to be available in the new version of the api. This is how moonlight approaches api versioning.\nAt its core, Moonlight still uses a controller paradigm but this is just one for your entire application. This controller is used capture all exceptions in your services and return a response to the client.\nBelow is an example of a switch in Moonlight based on Pionia Framework.\n\u0026lt;?php namespace application\\services; use Pionia\\Core\\BaseApiServiceSwitch; use application\\services\\UserService; class VersionOneSwitch extends BaseApiServiceSwitch { /** * Register your services here. * * @return array */ public function registerServices(): array { return [ \u0026#39;user\u0026#39; =\u0026gt; new UserService(), // this service will be available in version one of the api. ]; } }\rFor the above switch to be available in the application, you need to register it your app routes.\nAccording to Pionia, the routes.php file is used to register the switches that should be auto-dicovered.\nuse Pionia\\Core\\Routing\\PioniaRouter; $router = new PioniaRouter(); /** * This registers the switch for version one of the api. * This will be served at /api/v1/ */ $router-\u0026gt;addSwitchFor(\u0026#34;application\\switches\\MainApiSwitch\u0026#34;, \u0026#34;v1\u0026#34;); ", "date": "2024-05-24", "id": 2, "permalink": "/moonlight/api-versioning-in-moonlight/", "summary": "Moonlight basically has only one controller, one controller action and one endpoint. To get another version of the api, you just need to roll out a new controller action and a new endpoint. This is how moonlight approaches api versioning.", "tags": [], "title": "API Versioning in Moonlight" },
  { "content": "Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ", "date": "2023-09-07", "id": 3, "permalink": "/blog/example-post/", "summary": "You can use blog posts for announcing product updates and features.", "tags": [], "title": "Example Post" },
  { "content": "", "date": "2023-09-07", "id": 4, "permalink": "/blog/", "summary": "", "tags": [], "title": "Blog" },
  { "content": "\rAbout Welcome to the official documentation of pionia - /ˌpʌɪəˈnɪə/ framework. Pionia is a PHP Rest Framework that is truly RESTful. It is designed to be simple, lightweight, and easy to use. Pionia is built on top of the Moonlight architecture, which is a powerful architecture for powering highly scaling REST projects. Pionia provides a set of tools and conventions that make it easy to build RESTful APIs in PHP.\nThis framework was born at Service Cops - East Africa by JET and is maintained by the same team. The framework is open-source and is released under the MIT license.\nDocumentation organisation.\nMoonLight Architecture Tutorial App Structure Requests And Responss Middleware Security - Authentication and Authorization Services and Actions Database and Querying Get Started Start with a TO-DO api tutorial\nYou can quickly get started with our To-Do API tutorial. This guide introduces you to the both the framework and the Moonlight architecture. It is the recommended way to start your pionia jungle journey.\nWhy Pionia? There are various reasons why pionia stands out from other PHP frameworks. From program performance, developer performance, to maintainability, pionia has got you covered.\nYou can read more about Why Pionia here.\nInstallation Pre-requisites PHP 8.0 or higher preferably 8.1. You can download PHP from php.net Any web server (Apache, Nginx, etc.) for production Composer Any RDBMS of Postgres, MySQL/MariaDB, Oracle, Sybase, MSSQL or SQLite Note: This guide assumes you have Composer installed and running globally. If you don\u0026rsquo;t, you can download it from getcomposer.org or use the Composer Docker image.\ncomposer\rGit templates\rcomposer create-project pionia/pionia-app my-project\rRemember to replace my-project with the name of your project.\nSelect use this template on the repository page. Download directly the compressed file from the releases page. Nginx configurationss\nThis is just a sample configuration. You can modify it to suit your needs. But make sure your configuration points to the index.php file of your project.\n# ...rest of your configurations # projet_name [replace this with your project name] location /projet_name { alias /var/www/html/project_name; try_files $uri $uri/ @project_name; } location @project_name { rewrite /project_name/(.*)$ /project_name/index.php?/$1 last; } # ... rest of your configurations\rContributing However, the framework is maintained by a dedicated team and welcomes you as our next contributor on any of our related projects.\nYou can contribute to the framework, documentation or by helping us grow the community through writing articles, tutorials, and sharing your experience with the framework on any media platform.\nThe framework itself strips off all the unnecessary features that are found in other frameworks and leaves you with only what you need to build a RESTful API. This means you can also contribute by building plugins and extensions that can be used with the framework.\nIf you want to contribute to this documentation, you can find the source code on GitHub.\nPlease read the contributing guidelines before contributing.\nPlease note that this project is released with a Contributor Code of Conduct\n", "date": "2024-05-24", "id": 5, "permalink": "/documentation/introduction/", "summary": "About Welcome to the official documentation of pionia - /ˌpʌɪəˈnɪə/ framework.", "tags": [], "title": "Introduction" },
  { "content": "\rPionia was developed to make it easy for developers to build high-performance REST applications removing the unnecessary complexities that come with most common traditional frameworks. Developers stay focused on the business logic only.\nPionia is all the beautiful parts of Moonlight paradigm. But as the framework, it also has its own unique features. Here are some of the reasons why you should consider using Pionia:\nSimplicity: Pionia is designed to be simple and easy to use. It has a clean and intuitive API that makes it easy to get started with. Remember that boilerplate code you usually get after installing most frameworks? Pionia doesn\u0026rsquo;t have even quarter of that. Staff like controllers, routes, models are not here. You just need to write your services, and you are good to go.\nQuery Builder: Pionia comes with a powerful query builder that makes it easy to interact with the database. We know you\u0026rsquo;re already used to models and ORM. This has both pros and cons. Models usually undergo a process called model hydration while populating the resultset into your model class. This can really be more expensive especially when you\u0026rsquo;re dealing with large datasets. Pionia uses a query builder that returns everything as arrays and objects. This is more efficient and faster. You can read more about Pionia Query Builder here.\nPerformance: Pionia is built with performance in mind. It is lightweight and fast, making it ideal for building high-performance api applications. It is also designed to be scalable, so you can easily add more resources as your application grows. You will be surprised how fast your api will be.\nApi Versioning: Pionia has a unique approach to api versioning. Every switch implies a new version of the api. This means that you can easily add new versions of your api without having to change your existing code. Just roll out a new switch and you are good to go.\nSecurity: Pionia has built-in security features that help protect your application from common security threats. It also has a flexible authentication system that allows you to easily integrate with third-party authentication providers. Pionia\u0026rsquo;s authentication especially the authentication backends are inspired by Django and Spring boot authentication system but with less conventions and more configurations. We keep an open mind on what you want your backend to authenticate with and we provide you with the tools to do so. We also have a built-in role-based access control system that allows you to easily manage user permissions and access control. You can look at in the Authentication and Authorization Section\nDeveloper Performance: Using Pionia, rolling out an api should not take even hours. This is achieved by the fact that you don\u0026rsquo;t need to write a lot of boilerplate code. You just need to write your services and you are good to go. This becomes even simpler if you\u0026rsquo;re using our Generic Services.\nMoonlight Compatibility: Pionia follows the standards defined by Moonlight. Advantages like, single endpoint, single request format, single response format, single switch per api version, every request being post and many more\u0026hellip; are all here. Moonlight strips away the unnecessary complexities that come with most common traditional frameworks. Developers stay focused on the business logic only. However much this seems to be a new pattern, most platforms have used this platform for years, and it has been proven to be an excellent option for building high-performance api applications. Get started with moonlight pattern here\nSingle Request and Response Format: In Pionia projects, all requests carry the same format and all responses too. This makes it easy to understand and work with the api especially on the frontend side.\nCommunity: Pionia has a growing community of developers who are passionate about building high-performance api applications. You can find help and support from the community through discord, twitter, and other social media channels.\nFrontend Scaffolding and Serving: Pionia is a backend REST framework. But we also scaffold most frameworks especially those supported by vite. We also have a clean way of serving these frameworks\u0026rsquo; build files and assets at the root of the Pionia backend. This is especially useful when you want to serve your frontend and backend from the same server. You can read more about this in the Frontend Scaffolding and Serving Section.\nWe also take most of the other advantages listed by most other frameworks like inbuilt logging, error handling, and many more.\nConclusion Not everything is as you expected in Pionia. We recommend you to first appreciate the moonlight paradigm(also nicknamed single endpoint paradigm or SS\u0026amp;R - Services, Switches and Routes) before you start using Pionia. This will help you understand the philosophy behind Pionia. The paradigm of Single endpoint, single route, single switch, single request format and single response format is what makes Pionia unique.\nAlso, please note that Pionia is a REST framework and it intends to keep that way. If you\u0026rsquo;re looking for something else, like a full stack framework, you might want to consider other frameworks like Laravel, Symfony, Yii2, CakePhp, CodeIgnitor and others.\n", "date": "2024-05-24", "id": 6, "permalink": "/documentation/why-pionia/", "summary": "Pionia was developed to make it easy for developers to build high-performance REST applications removing the unnecessary complexities that come with most common traditional frameworks.", "tags": [], "title": "Why Pionia?" },
  { "content": "Taking our directory structure from the API Tutorial we created here.\nbootstrap ├── application.php ├── routes.php environment ├── .env ├── settings.ini public ├── index.php ├── .htaccess services ├── AuthService.php static ├── bootstrap.min.css ├── favicon.ico ├── favicon.png ├── pionia_logo.webp storage ├── scripts ├── rename.php switches ├── MainSwitch.php ├── .gitignore ├── README.md ├── composer.json ├── pionia\rDirectory Structure Breakdown Name Role Type bootstrap This is where we store our application and routes. application.php helps to bootstrap the Pionia application that shall be used by both our CLI and web kernels. Folder environment This holds our environment configuration files, can contain profile-specific environment too! Folder public This handles all HTTP requests and boots up our web kernel using the Pionia application created in bootstrap/application.php Folder services This is where all our services are stored. This is where you should focus most. All business logic resides here. Folder static These holds static files that the might you may need or that might be needed by the framework itself. In the future, this folder might be used to serve frontend SPAs Folder storage This where application generated files are stored. These might include caches, logs, and scripts. Please do not remove rename.php in scripts Folder switches This is where our app switches reside. Folder .gitignore This file is used to tell git which files to ignore when pushing to the repository. File composer.json This file is used to manage the dependencies of the project. It is used by composer to install the dependencies. File pionia This handles all our CLI commands, whether inbuilt or your custom commands. Just run php pionia to boot this CLI up File README.m A simple getting started guide for the project. File Pionia is a progressive framework, there more folders might be included as you need/require them. Other folders might include middlewares, authentications, commands. All these will only be added when you invoke/initiate them.\n", "date": "2024-05-24", "id": 7, "permalink": "/documentation/application-structure/", "summary": "Taking our directory structure from the API Tutorial we created here.", "tags": [], "title": "Application Structure" },
  { "content": "Pionia is a REST framework that is entirely meant for the backend. It has no frontend capabilities.\nHowever, Pionia has added support to scaffold one of the seven vite-supported frameworks. This is to help you get started with your frontend quickly.\nSupported Frameworks To get the full list of supported frameworks, you can run the following command:\nphp pionia front:sc\rThe following are the supported frameworks:\n[0] Vue [1] React [2] Z-js [3] Qwik [4] Lit [5] Preact [6] Svelte [7] Solid You should scaffold using our commands if you need Pionia to manage your frontend. If you are using a different frontend framework, you can scaffold it manually.\nScaffold Frontend To scaffold the frontend, you can run the following command:\nphp pionia front:sc\rIf you pass -y flag, the command will assume the defaults and scaffold the frontend without asking for any input. This will scaffold Vuejs in the frontend directory of your project using npm as the package manager.\nScaffold Specific Framework Just select the option of the framework you want to scaffold. For example, to scaffold React, you can run the following command:\nphp pionia front:sc\rThen select the option for React which is 1 as illustrated in the image above.\nFrontend Directory/folder. The frontend directory is where all the frontend code is stored. It is created by the front:sc command. The directory is created in the root of your project.\nIn the interactive shell of the front:sc command, you can specify the name of the directory you want to create. If you do not specify a name, the default name is frontend.\nIn the shell below, enter no to provide your custom frontend directory.\nExample below will scaffold the frontend in the pages folder\nFrontend Package Manager In the interactive shell of the front:sc command, you can specify the package manager you want to use. If you do not specify a package manager, the default package manager is npm.\nThe following are the available options:-\nIf you selected z-js, we recommend you to select either npm or yarn as the package manager.\nThe package you select should already be setup in your system. If you select any package that you do not have installed, the command will fail.\nScaffolding TS or JS Except z-js, for the other frameworks, you can choose between scaffolding the js or the ts version of the framework.\nThis will always default to js.\nOther Frontend Operations. Pionia does not just stop at scaffolding the frontend. It also, gives you other features that you can do with your frontend.\nEnvironment Setup Pionia sets up both the backend and the frontend environments so that they start communicating. In the backend, the following will be added in your settings.ini upon successful scaffolding of the frontend.\n[frontend] frontend_root_folder=pages build_command=yarn build frontend_build_folder=dist frontend_framework=Vue package_manager=yarn\rThe frontend tells Pionia how to deal with the frontend that was just created.\nfrontend_root_folder is the root folder of the frontend. This is where the frontend code is stored. build_command is the command that will be run to build the frontend. This command is run as is against your frontend, so feel okay to tweak it the way you see fit. frontend_build_folder is the folder where the frontend will be built. Usually if this is not in dist, it will absolutely be in the build folder. When Pionia is going to serve your frontend, this is the folder it will read and ship to your backend. frontend_framework is the framework that was used to scaffold the frontend. package_manager is the package manager that was used to scaffold the frontend. This will be the package manager used even to build your frontend. In the frontend directory created, two files were created. These might likely be in your src folder. Pionia adds the VITE_API_URL to your .env file. This is the url that your frontend will use to communicate with the backend.\nIn development mode, this will be http://localhost:8000/api/. In production mode, this will be relative to your application domain since the frontend and backend will be served together.\n.env.development - This is the file that will be used to set the environment variables for your frontend in development mode. # .env.development VITE_API_URL=http://localhost:8000/api/\r.env.production - This is the file that will be used to set the environment variables for your frontend in production mode. # .env.production VITE_API_URL=/api/\rYou need to call this VITE_API_URL as your base url in your frontend whenever you want to make any http calls to your API.\nBuild the frontend. In development, the frontend and backend run in isolation. This implies that both the frontend and backend servers must be started and run in two terminals. However, when you are done with your frontend, Pionia kicks in again.\nBuilding the frontend and serving it with your backend.\nBefore proceeding, running http://localhost:8000/ if your backend is still running on the default port, you will see the default Pionia page.\nTo build the frontend, you can run the following command:\nphp pionia front:build\rThis command will build your frontend in your frontend directory, into your build folder, then will ship them to your backend for serving.\nOn successful running of the above command, http://localhost:8000/ should render your frontend instead.\nBefore build http://localhost:8000/\nAfter build http://localhost:8000/\nCleaning up the build files. When you serve your frontend with your backend, Pionia drops all the necessary files in your root directory for serving. This can be messy and hard to truck.\nFuture versions might handle this in the public folder. But for now, Pionia has a way of trucking these files and cleaning them our if you nolonger want them.\nRun the following command to clean the frontend served with backend. This is ensured by the manifest.json file that was created with the build command.\nphp pionia front:build:clean\rOn success, your root directory will be clean and only containing php files.\nDropping the entire frontend! In cases where maybe you wanted to scaffold Vuejs and instead scaffolded React, you can run this command to drop your entire frontend.\nphp pionia front:drop\rIt is advisable to run this command after running the front:build:clean so that any files that were created by the build command are also cleaned up.\nThis operation is irreversible and leads to losing your entire frontend progress. If you\u0026rsquo;re not sure, please do not run this command.\nWith this in, Pionia now can handle both the backend and help you with your backend while maintaining each of them in isolation.\nNeed Help? For any technicalities that you may interface in this section, please refer to the vite docs for the specific framework you are using or the official documentation of the framework you\u0026rsquo;re trying to scaffold.\n", "date": "2024-05-24", "id": 8, "permalink": "/documentation/frontend-integration/", "summary": "Pionia is a REST framework that is entirely meant for the backend.", "tags": [], "title": "Frontend Integration" },
  { "content": "\rThis section assumes that you have already setup your Pionia framework project. If you haven\u0026rsquo;t done that, please head over to Installation section for details.\nThis guide also introduces you to the implementation of the Moonlight architecture, so you can check it out first to get familiar with the terminologies.\nOut Target We should be able to accomplish the following tasks by the end of this tutorial:\nInitialize the project. Connect to a database. Create your first service. Create or update a to-do item in the database. Retrieve all to-do items from the database. Retrieve a single to-do item from the database. Retrieve n random to-do item[s] from the database. Delete a to-do item from the database. Prerequisites You should have a basic understanding of PHP. You should have postman installed on your machine for testing the API. You should have a database created already. Step 1: Initialize the project To create a new project, you need to run the following command in the directory you want your project to be created. We are calling ours todo_api.\ncomposer create-project pionia/pionia-app todo_api\rWe can open the project in our favorite code editor or IDE, for this tutorial we will be using PhPStorm IDE.\nAll IDEs and Editors should be supported for use since Pionia is powered by PHP that is supported by most of the IDEs.\nFor explanation of the directories and scripts, please refer to the Structure Section of this documentation.\nTo confirm that our installation works fine, let\u0026rsquo;s just go start our server. Open the terminal in the root of the project and run the following command.\nphp pionia serve\rIf everything is setup correctly, your project should be up and running on http://127.0.0.1:8000. Visiting this url, you should see the following page.\nWe can test if our APIs are also working fine by visiting http://127.0.0.1:8000/api/v1/. It should return the following in the browser.\n{ \u0026#34;returnCode\u0026#34;:0, \u0026#34;returnMessage\u0026#34;:\u0026#34;pong\u0026#34;, \u0026#34;returnData\u0026#34;:{ \u0026#34;framework\u0026#34;:\u0026#34;Pionia Framework\u0026#34;, \u0026#34;version\u0026#34;:\u0026#34;2.0.2\u0026#34;, \u0026#34;port\u0026#34;:8000, \u0026#34;uri\u0026#34;:\u0026#34;\\/api\\/v1\\/\u0026#34;, \u0026#34;schema\u0026#34;:\u0026#34;http\u0026#34; }, \u0026#34;extraData\u0026#34;:null }\rInitialize the project(Completed) Step 2: Connect to a database Pionia removes the section of models and migrations and instead uses a simple and lightweight query builder to interact with the database - PORM.\nAt its heart, PORM was initially a wrapper on top of medoo, a lightweight database framework that makes interacting with the database easy and fun. However, from v2.0^, the core medoo package was re-written to meet Pionia-specific needs and added to the core Pionia.\nYou can create a new database or use an existing one as you see fit!\nAssuming you have already setup your MySQL database.\nLet\u0026rsquo;s first create our MySQL database as below:\nCREATE DATABASE todo_db; USE todo_db;\rThen we can create a table called todos as below:\ncreate table if not exists todos ( id int auto_increment primary key, title varchar(200) not null, description text, created_at timestamp default CURRENT_TIMESTAMP ); desc todos;\rAbove should return the following:\nDatabase configurations in the environment should be done in any .ini files. You can create a dedicated database.ini file or just use the existing settings.ini.\nBut why do we have have to do this from .ini files?\nPionia supports connection to multiple database at ago. Using .ini files, these can just be sections. Forexample, our first database can called [db], and then our second can [db2]. Pionia will auto-discover these and collect them in the container as needed. To set a database as the default, just add default=1 or default=true in its section.\nOpen settings.ini file and update the database settings as below:\nsettings.ini\r[db] database = \u0026#34;todo_db\u0026#34; # your database name username = \u0026#34;root\u0026#34; # your database user type = \u0026#34;mysql\u0026#34; # your database type host = \u0026#34;localhost\u0026#34; password = \u0026#34;\u0026#34; # your database password port = 3306 default=true # to mark it as our default db connection\rConnect to a database(Completed) Throughout this tutorial, we will be creating everything manually, however, pionia cli can be used to create most of the staff for you.\nJust run the following command in your terminal to see the available commands. And you can always add your own commands like illustrated in this section\nphp pionia\rStep 3: Create your first service - TodoService Since all our business logic is related to To-do items, we only need one service called TodoService.\nPoints to ponder! All Pionia services reside in the services folder under the Application\\Services.\nAll Pionia Services should extend Service from Pionia\\Http\\Services\\Service.\nAt its most minimal nature, this is a valid Pionia Service. For details about services, please through the detailed guide here\nTodoService.php\r\u0026lt;?php namespace Applications\\Services use Pionia\\Http\\Services\\Service; class TodoService extends Service { }\rService Registration - Switches. Pionia introduces the concept of switches to help in api versioning. Be default, your new application already consists of MainApiSwitch which maps all requests targeting /api/v1/. When can create switches manually or via the cli, but all in all, these should only define one method registerServices which returns a Pionia Pionia\\Collections\\Arrayable. In this Arrayable, you can register all your services that should be under the same version like /api/v1. For details, about switches, please head over to Service Registration section of services.\nFor now, let\u0026rsquo;s register our created service in the MainApiSwitch class. Open MainApiSwitch.php in the switches folder and add the following code in our registerServices method.\nMainApiSwitch.php\rpublic function registerServices(): Arrayable { return arr([ \u0026#39;user\u0026#39; =\u0026gt; UserService::class, \u0026#34;todo\u0026#34; =\u0026gt; TodoService::class, // add this line here ]); }\rNow our service is discoverable by the framework.\nCreate the service(Completed) Step 4: Create or update a to-do item in the database - 1st action. Pionia Actions. To their simplest, these are just class methods with a little sugar-coating. As we have already seen, Pionia services are just PHP classes that extend from Service. All methods defined in these services(classes) that are suffixed by Action and return Pionia\\Http\\Response\\BaseResponse, are taken to be Pionia Actions. Therefore, any other methods defined in Pionia Service without an Action suffix are taken to be just class methods not a Pionia Action.\nFor Details about Pionia Actions, please read more about the details here.\nWe create our first action in our service called \u0026lsquo;createOrUpdateAction\u0026rsquo;. This action will be responsible for creating a new to-do item in the database or update an existing one if an id is provided.\nTodoService.php\rnamespace Application\\Services; use Pionia\\Collections\\Arrayable; use Pionia\\Http\\Response\\BaseResponse; use Pionia\\Http\\Services\\Service; class TodoService extends Service { public function createOrUpdateAction(Arrayable $postData) : BaseResponse { $title = $data-\u0026gt;getString(\u0026#34;title\u0026#34;); $description = $data-\u0026gt;getString(\u0026#39;description\u0026#39;); $id = $data-\u0026gt;getInt(\u0026#34;id\u0026#34;); if (!$id){ $saved = table(\u0026#34;todos\u0026#34;) -\u0026gt;save( [\u0026#39;title\u0026#39; =\u0026gt; $title, \u0026#39;description\u0026#39; =\u0026gt; $description] ); $message = \u0026#34;Todo created successfully!\u0026#34;; } else { db(\u0026#34;todos\u0026#34;) -\u0026gt;update([ \u0026#39;title\u0026#39; =\u0026gt; $title, \u0026#39;description\u0026#39; =\u0026gt; $description, ], $id); $saved = db(\u0026#34;todos\u0026#34;)-\u0026gt;database-\u0026gt;id(); $message = \u0026#34;Todo updated successfully!\u0026#34;; } return response(0, $message, $saved); } }\r✨So, briefly to go through what we just did.\nWe created our action which takes up a Pionia Arrayable $postData which will always contain our POST request data. We collected our data, title and description as a string, the id as an integer. We checked if we actually have an id in our request. If no id was provided, we use the post data given to us to create a new todo, otherwise we updated the matched to-do. Finally, we returned a response using one of our Pionia Helpers Sending the request using any client of choice.\nSo, in the request, using the above, we defined that everytime we define a SERVICE or service called todo, our TodoService should then be loaded. Remember, all services are lazy-loaded, so, Pionia does not know that this service exists till it\u0026rsquo;s required by the incoming request.\nFor actions, the same process applies. All actions are lazy-loaded too.\nBut how do we then target our actions, a case here, createOrUpdateAction?\nTo hit out action, another key called ACTION or action must be passed in our request post data.\nThis can target the action name directly as the method name:-\n{ \u0026#34;SERVICE\u0026#34; : \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34; : \u0026#34;createOrUpdateAction\u0026#34; }\rOr we can ignore the Action suffix like this.\n{ \u0026#34;SERVICE\u0026#34; : \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34; : \u0026#34;createOrUpdate\u0026#34; }\rOr if you love snake_case format, you can also pass it like below\n{ \u0026#34;SERVICE\u0026#34; : \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34; : \u0026#34;create-or-update\u0026#34; // can also be \u0026#34;create-or-update-action\u0026#34; }\rjet-fetch JSON\rAxios FormData(postman)\rAxios JSON Data(Postman)\rXHR -JSON (Postman)\rimport { Jet } from \u0026#39;jet-fetch\u0026#39;; const jet = new Jet({ baseUrl: \u0026#39;http://localhost:8000/api/\u0026#39;, }); jet .moonlightRequest({SERVICE: \u0026#39;todo\u0026#39;, ACTION: \u0026#39;createOrUpdate\u0026#39;, title: \u0026#39;Pass this \u0026#39;, description: \u0026#39;Must pass\u0026#39; }, \u0026#39;v1\u0026#39;) .then((response) =\u0026gt; { const { returnCode, returnMessage, returnData, extraData } = response.data; console.log(returnCode, returnMessage, returnData, extraData); }).catch((error) =\u0026gt; { console.log(error); });\rconst axios = require(\u0026#39;axios\u0026#39;); const FormData = require(\u0026#39;form-data\u0026#39;); let data = new FormData(); data.append(\u0026#39;title\u0026#39;, \u0026#39;Pass this \u0026#39;); data.append(\u0026#39;description\u0026#39;, \u0026#39;Must pass this\u0026#39;); data.append(\u0026#39;service\u0026#39;, \u0026#39;todo\u0026#39;); data.append(\u0026#39;action\u0026#39;, \u0026#39;create\u0026#39;); let config = { method: \u0026#39;post\u0026#39;, maxBodyLength: Infinity, url: \u0026#39;http://localhost:8000/api/v1/\u0026#39;, headers: { ...data.getHeaders() }, data : data }; axios.request(config) .then((response) =\u0026gt; { console.log(JSON.stringify(response.data)); }) .catch((error) =\u0026gt; { console.log(error); });\rconst axios = require(\u0026#39;axios\u0026#39;); let data = JSON.stringify({ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;create\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34; }); let config = { method: \u0026#39;post\u0026#39;, maxBodyLength: Infinity, url: \u0026#39;http://localhost:8000/api/v1/\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, data : data }; axios.request(config) .then((response) =\u0026gt; { console.log(JSON.stringify(response.data)); }) .catch((error) =\u0026gt; { console.log(error); });\rvar data = JSON.stringify({ \u0026#34;service\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;create\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34; \u0026#34;id\u0026#34;: 2 // this is optional, only pass it to update. }); var xhr = new XMLHttpRequest(); xhr.withCredentials = true; xhr.addEventListener(\u0026#34;readystatechange\u0026#34;, function() { if(this.readyState === 4) { console.log(this.responseText); } }); xhr.open(\u0026#34;POST\u0026#34;, \u0026#34;http://localhost:8000/api/v1/\u0026#34;); xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;);\rOn Successful execution, the above code should return the following:\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todo updated successfully!\u0026#34;, \u0026#34;returnData\u0026#34;: { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:11:23\u0026#34; }, \u0026#34;extraData\u0026#34;: null }\rAnd in the database, we should have the following:\nBefore we proceed, let\u0026rsquo;s first understand what just happened above.\nWhen you reached the endpoint http://localhost:8000/api/v1/ with the data as shown above, the request came via our public/index.php, which loaded out routes. We only have one route as follows:-\nbootstrap/routes.php\ruse Application\\Switches\\MainSwitch; use Pionia\\Http\\Routing\\PioniaRouter; $router = (new PioniaRouter()) -\u0026gt;wireTo(MainSwitch::class);\rThe above route implies that all requests to http://localhost:8000/api/v1/ should be handled by the MainApiSwitch switch.\nThe main api switch checks in the request body for the SERVICE and ACTION keys. If they are not found, it throws an exception. If they are found, it maps the request to the service and action mentioned basing on the registered services. Therefore, for your service to be discovered, you must register it as we did here.\nSo, after here, the service needed is loaded and the entire request in forwarded to it. When the service receives the request, it checks for the action mentioned in the request body. If the action is not found, it throws an exception. If the action is found, it executes the action and returns a response back to our client.\nCreate or update a to-do item in the database(Completed) Step 5: Retrieve all to-do items from the database - 2nd action. We created our todo from the above step, please first take time to create as many as you want.\nNow, let\u0026rsquo;s create an action called listAction in our service to retrieve all to-do items from the database.\nTodoService.php\r## ..rest of the service code protected function listAction(Arrayable $data): BaseResponse { return response(0, null, table(\u0026#34;todos\u0026#34;)-\u0026gt;all()); } ## rest of the service code... Now, let\u0026rsquo;s change our JSON in postman to the following:\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;list\u0026#34; }\rSend the request and you should get the following response:\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todos found.\u0026#34;, \u0026#34;returnData\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;Pass this \u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Must pass this\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:04:17\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:11:23\u0026#34; } ], \u0026#34;extraData\u0026#34;: null }\rPoint To Ponder\nNotice how the returnData is an array, yet it was an object in the previous response. returnData and extraData can be of any type, it is up to you to decide what to return in them.\nYou can also omit the message by setting it to null which should be logical for cases of listing items.\nRetrieve all to-do items from the database(Completed) Step 6: Retrieve a single to-do item from the database - 3rd action. We will create an action called retrieveAction in our service to retrieve a single to-do item from the database.\nTodoService.php\r## ..rest of the service code /** * @throws DatabaseException */ protected function retrieveAction(Arrayable $data): BaseResponse { $this-\u0026gt;requires(\u0026#39;id\u0026#39;); $id = $data-\u0026gt;get(\u0026#39;id\u0026#39;); $todo = db(\u0026#34;todos\u0026#34;) -\u0026gt;get($id); if (!$todo){ throw new Exception(\u0026#34;No todo with id $todo found.\u0026#34;); } return response(0, null, $todo); } ## ..rest of the service code Here we are going to test two scenarios, one is where everything goes smoothly and the other is where the server panics(throws an exception).\n{ \u0026#34;SERVICE\u0026#34;:\u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;retrieve\u0026#34;, \u0026#34;id\u0026#34;: 2 }\r{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;retrieve\u0026#34;, \u0026#34;id\u0026#34;: 100 }\rIn the first scenario, we get back a status code of 200 OK with the following response.\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: null, \u0026#34;returnData\u0026#34;: { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:11:23\u0026#34; }, \u0026#34;extraData\u0026#34;: null }\rBut in the second scenario, we still get a status code of 200 OK but with the following response.\n{ \u0026#34;returnCode\u0026#34;: 400, \u0026#34;returnMessage\u0026#34;: \u0026#34;No todo with id 100 found.\u0026#34;, \u0026#34;returnData\u0026#34;: null, \u0026#34;extraData\u0026#34;: null }\rPoint To Ponder\nNotice how the exception message becomes our returnMessage. This exception was caught by our switch. Therefore, wherever you\u0026rsquo;re in the services, feel free to throw any exceptions with clean messages.\nRetrieve a single to-do item from the database(Completed) Step 7: Grab n random to-do item[s] from the database - 7th action. TodoService.php\r## ..rest of the service code public function randomAction(Arrayable $data) : BaseResponse { $length = $data-\u0026gt;get(\u0026#39;length\u0026#39;, 1); $todos = db(\u0026#34;todos\u0026#34;) -\u0026gt;random($length); return response(0, null, $todos); }\rYou can keep hitting this action and on each hit, you should get a different to-do item. You can also play with the length parameter to get more or less to-do items.\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;random\u0026#34;, \u0026#34;length\u0026#34;: 1 }\rGrab n random to-do item[s] from the database(Completed) Step 8: Delete a to-do item from the database - 5th action. If you followed along upto this far, you should be able to implement this on your own. If you get stuck, you can refer to the code below.\nTodoService.php\rpublic function delete($data) : BaseResponse { $id = $data[\u0026#39;id\u0026#39;]; Porm::from(\u0026#34;todos\u0026#34;)-\u0026gt;delete($id); // you can now hit \u0026#39;all\u0026#39; to see if this worked, // you should notice item with this id disappears. return BaseResponse::JsonResponse(0, \u0026#34;Todo deleted.\u0026#34;); } public function deleteAction(Arrayable $data) : BaseResponse { $this-\u0026gt;requires(\u0026#34;id\u0026#34;) $id = $data-\u0026gt;get(\u0026#39;id\u0026#39;); $todo = db(\u0026#34;todos\u0026#34;) -\u0026gt;delete($id); return response(0, \u0026#34;Todo deleted successfully\u0026#34;); } Change your request object to the following in your client(postman).\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;delete\u0026#34;, \u0026#34;id\u0026#34;: 2 }\rIf you did everything right, you should get your response as follows\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todo deleted successfully\u0026#34;, \u0026#34;returnData\u0026#34;: null, \u0026#34;extraData\u0026#34;: null }\rDelete a to-do item from the database(Completed) Point To Ponder\nAll our requests are made via POST method. All our requests have similar body structure, they have a SERVICE, ACTION, and other param keys. All our responses have the same response format, returnCode, returnMessage, returnData, and extraData keys. We are hitting the same endpoint http://localhost:8000/api/v1/ for all our requests. We did not touch the routes or the kernel. but we only focused on the service! This is the beauty of the Moonlight architecture. It makes it easy to understand and maintain your code.\nImagine how fast you would pull off a new service with Pionia.\nPost Tutorial \u0026ndash; What Next? Deep Dive into Pionia Requests\rExplore more features about the Pionia Requests and the request cycle.\n", "date": "2024-05-24", "id": 9, "permalink": "/documentation/api-tutorial/", "summary": "This section assumes that you have already setup your Pionia framework project.", "tags": [], "title": "API Tutorial" },
  { "content": "", "date": "2024-07-05", "id": 10, "permalink": "/docs/documentation/services/", "summary": "Some actions like list, delete, create, retrieve/details, random, updated, are provided by default. You can still add more actions as you see fit.", "tags": [], "title": "Services" },
  { "content": "\rThis section assumes that you have a basic understanding of the Pionia framework. If you are new to Pionia, you can start with the tutorial.\nIntroduction Services in Pionia Framework are central holders of business logic. This is where most of the work happens. Pionia has tried to reduce your work from other areas so that you mainly focus on this essential area. Services are in actual PHP code, just php classes that extend the BaseRestService. As you might already know, a class can have multiple methods. In Pionia we call these Actions. Therefore, henceforth, the terms service and actions will be used for the same meaning throughout the same guide.\nCreating a service You can create a service using our pionia console or manually. All services, as a convention, must be located in the services folder.\nWe recommend to name your services after your database tables. Example, if your table is called \u0026lsquo;users\u0026rsquo;, you can name your service \u0026lsquo;UserService\u0026rsquo;.\nIf you are using our \u0026lsquo;pionia console\u0026rsquo;, then you can just name your service \u0026lsquo;user\u0026rsquo;. These are just conventions!\npionia command\rManually\rLet\u0026rsquo;s create a service called TodoService. In the terminal run the following command.\nphp pionia gen:service todo\rRunning the above command will prompt you for two options.\nBasic - These are services that extend the BaseRestService. They are close to creating manual services. If you select this option, you will be prompted to add actions to your service. You can add as many actions as you want or let the cli add the default actions of create, retrieve, update, delete for you. Once you are done, the service will be created in the services folder. You can delete or add more actions as you see fit.\nGeneric - These are services that extend the GenericService. They come with an entire CRUD logic out of the box. Once you select this option you will presented with a list of nine options to choose from. If you are not sure of what to select, just hit enter and the cli will select the default option for you which is the UniversalGenericService. This service comes with all the CRUD logic out of the box. Other Options are :-\n[0] UniversalGenericService\n[1] RetrieveListUpdateDeleteService\n[2] RetrieveListUpdateService\n[3] RetrieveListRandomService\n[4] RetrieveListDeleteService\n[5] RetrieveListCreateUpdateService\n[6] RetrieveListCreateService\n[7] RetrieveCreateUpdateService\n[8] GenericService\nChoosing option 8 gives you freedom to define your own mixins to extend.\nHead over to your services folder. Create a new service with a clear name, such as UserService, AuthService, CartService Extend BaseRestService Add your own actions each taking in data(post request data), files(ff your service is expecting files) and returning BaseResponse. Add your logic Remember generic services target a base table.\nTherefore, you shall be asked the table you want to target. This is required.\nHowever, starting from version 1.1.7, you can target relationships too!\nYou can read more about this in the Generic Services Section.\nService Registration Creating a service is not enough in Pionia. You also need to register it in our switcher to make it discoverable by the kernel. Service registration happens in the associated switch.\nIn the switches folder, find the switch you want to use for this service. You can add your service as below.\npublic function registerServices(): array { return [ \u0026#39;user\u0026#39; =\u0026gt; new UserService(), \u0026#34;todo\u0026#34; =\u0026gt; TodoService::class, // this is okay \u0026#39;auth\u0026#39; =\u0026gt; new AuthService(), // and this too ]; }\rThe key of this method is the name you shall use in your proceeding requests to access this service. Therefore, it must be unique!\nA single service can be registered in multiple switches. This is useful when you want to use the same service in different api versions.\nTargeting a service in the request In the request, you can target a service by determining the SERVICE key with your service name as the key defined in the registerServices method.\n{ SERVICE: \u0026#39;user\u0026#39; // rest of your request data. }\rTargeting a service action To target an action in a certain service, you need to define both the service and action as below.\n{ SERVICE: \u0026#34;user\u0026#34;, ACTION: \u0026#34;loginAuth\u0026#34; // rest of your service data }\rThe action in every request should match the name of your method in your service action. Pionia uses auto-discovery to automatically call the method passing in every required data needed for the request.\nThe keys SERVICE and ACTION are reserved and should not be used for any other purpose in the request data.\nThe same keys are case-sensitive and should be in uppercase.\nRequest Data and Response Accessing the Request object in the services You can access the request object in your service by calling the $this-\u0026gt;request method on the service object. This returns the Pionia\\Request\\Request object. You can use this to access anything on the request.\nclass TodoService extends BaseRestService { // your other actions here protected functon getTodo($data): BaseResponse { $request = $this-\u0026gt;request; $uri = $this-\u0026gt;request-\u0026gt;getUri(); // rest of actions logic } }\rRequest Data JSON and Form Request Data An action takes $data as the first parameter which is an array of the request data. You can access you post data from this parameter.\nThis consists of both JSON and form data. Therefore, you can access your data as below.\n$username = $data[\u0026#34;username\u0026#34;]; $email = $data[\u0026#34;email\u0026#34;];\rYou can also access your request data from the $this-\u0026gt;request object.\n$allData = $this-\u0026gt;request-\u0026gt;getData();\rYou can also access the request method, headers, and other request data from the $this-\u0026gt;request object.\n$method = $this-\u0026gt;request-\u0026gt;getMethod(); $headers = $this-\u0026gt;request-\u0026gt;getHeaders();\rMultipart Data(Uploads) If your action expects multipart upload files, then you can get these from the second action parameter called $files. This is an associative array of all uploads.\nprotected function profileUpdates(array $data, ?array $files) { $profilePic = $files[\u0026#39;profile_pik\u0026#39;]; }\rNOTE: This does not consist of base64 encoded uploads, for those, they\u0026rsquo;ll be part of the $data.\nAction Response. All actions must return a Pionia\\Response\\BaseResponse object. This is the object that is sent back to the client. You can use the BaseResponse object to send back a response with a status code, message, and data.\nA helper method BaseResponse::JsonResponse is provided to help you create a response object that is ready to be serialized to JSON.\nuse Pionia\\Response\\BaseResponse; class TodoService extends BaseRestService { // your other actions here protected functon getTodo($data): BaseResponse { $this-\u0026gt;mustAuthenticate(); // rest of actions logic return BaseResponse::JsonResponse(200, \u0026#39;Todo fetched successfully\u0026#39;, $todo); } }\rFor details about request and responses, you can check the request and response section.\nAction protection You can protect your actions by determining that they require only authenticated requests(users) to be accessed. You can do this in three ways.\nGlobally in the service Entire service You can mark an entire service as requiring authentication by setting the $serviceRequiresAuth parameter to true.\nclass TodoService extends BaseRestService { public bool $serviceRequiresAuth = true; // all actions in this service require authentication. // your other actions here }\rSpecific actions You can also mark specific actions in a service as requiring authentication. Use the $actionsRequiringAuth parameter and add action names of actions that should be reached by authenticated users only.\nThis, unlike $serviceRequiresAuth, will only protect the actions listed in the array not the entire service.\nclass TodoService extends BaseRestService { public bool $actionsRequiringAuth = [\u0026#39;getTodo\u0026#39;]; // your other actions here }\rInternally in the action You can also call the mustAuthenticate method anywhere in your action, preferably the first line in the action method.\nclass TodoService extends BaseRestService { // your other actions here protected functon getTodo($data): BaseResponse { $this-\u0026gt;mustAuthenticate(); // only authenticated will exceed this point. // rest of actions logic } }\rDetails of how Pionia achieves authentication and authorization can be found in the authentication section.\nError Handling According to Moonlight architecture, all requests should return a 200 Ok status code. This is because the client should be able to know if the request was successful or not by checking the returnCode in the response body.\nAll normal responses set this internally and are always returning a 200 status code. By convention and by default, all requests that are successful return 0 as the returnCode. This implies that the server can define multiple other return codes for other scenarios.\nIn Pionia, we have a global exception handler that catches all exceptions thrown anywhere in the code. This is to ensure that the client always gets the same response format.\nAll exceptions thrown are caught will raise a 500 status code and the message of the exception will be sent back to the client as the returnMessage.\nTherefore, in your services and actions, you can throw exceptions as you see fit. And you don\u0026rsquo;t need to catch them at all!\nprotected function getTodo($data): BaseResponse { $this-\u0026gt;mustAuthenticate(); if($data[\u0026#39;id\u0026#39;] == null){ throw new \\Exception(\u0026#39;Todo id is required\u0026#39;); // will be caught globally! } // rest of actions logic return BaseResponse::JsonResponse(200, \u0026#39;Todo fetched successfully\u0026#39;, $todo); }\rPlease note that all exceptions are caught globally and sent back to the client. Therefore, you do not need to catch exceptions in your services. Developers need to set clean, descriptive exception messages in their exceptions to help the client understand what went wrong.\nDeactivating actions in a service BaseRestService provides a parameter $deactivatedActions that can be used to register all deactivated actions in a service. This is useful when you want to deactivate an action in a service without deleting it.\nclass TodoService extends BaseRestService { public array $deactivatedActions = [\u0026#39;getTodo\u0026#39;]; // one or more actions to deactivate. }\rDeactivated actions will not be called by the switcher. Therefore, they will not be accessible by the client.\n", "date": "2024-07-05", "id": 11, "permalink": "/documentation/services/services/", "summary": "Some actions like list, delete, create, retrieve/details, random, updated, are provided by default. You can still add more actions as you see fit.", "tags": [], "title": "Services" },
  { "content": "\rThis section assumes that you have a basic understanding of the Pionia framework. If you are new to Pionia, you can start with the tutorial.\nComing soon! ", "date": "2024-10-07", "id": 12, "permalink": "/documentation/services/actions/", "summary": "Actions are the central logic for the entire app, this will guide you on handling actions in Pionia Framework.", "tags": [], "title": "Actions" },
  { "content": "\rThis section assumes that you have a basic understanding how Services work in Pionia. If you haven\u0026rsquo;t, you can check the Services section first.\nIntroduction Pionia Generic Services get their inspiration from Django Rest Framework\u0026rsquo;s Generic Views. They provide a set of actions that are common in most CRUD applications. This is to help you focus on the complex business logic and not the repetitive CRUD work. But it is not just CRUD, you can query random and paginated data too. You can also add your own actions as you see fit. This feature is available starting from the core version of v1.1.2.\nThe Mixins There a few mixins that have been provided to help you with the CRUD operations. These mixins are:\nCreateMixin This mixin adds the create action to whatever generic service you have added. It is used to create a new record in the database. You can specify the columns to create in the table by providing the $createColumns array property in the service.\nDeleteMixin This mixin adds the delete action to whatever generic service you have added. It is used to delete a record from the database by pk_field defined in the service.\nListMixin This mixin adds the list action to whatever generic service you have added. It also detects if the request is paginated and applies the pagination to the data accordingly. You can customise the columns to return by defining the $listColumns array property in the service.\nRetrieveMixin This mixins adds two actions which actually perform the same operation. The retrieve and the details action. They are used to get a single record from the database by the pk_field defined in the service. If the $listColumns property is defined, it will return only those columns.\nRandomMixin This mixin adds the random action to whatever generic service you have added. The number of records returned is by default 1. But this can be overridden by defining the size or limit parameter in the request. If the size is finally one, it will return an object otherwise an array of objects.\nUpdateMixin This mixin adds the update action to whatever generic service you have added. It is used to update a record in the database. You can specify the columns to update in the table by providing the $updateColumns array property in the service. If these are not defined, then all/only the table columns that are defined in the request will be updated(partial update). Also, the item to update will depend on the pk_field defined in the service. By default this is id.\nThe mixins are not to be used outside services that extend the GenericService class. They are already included in the generic services. But if you want to use them, make sure you\u0026rsquo;re extending the GenericService class or any of the generic services defined below.\nThe GenericService This is the core class that provides the basis for all the actions. It is a class that extends the BaseRestService class so you no longer need to do that. All available methods can be found here in the api reference.\nYou don\u0026rsquo;t need to interact with this class directly but through the following generic services.\nRetrieveCreateUpdateService RetrieveListCreateService RetrieveListCreateUpdateDeleteService RetrieveListDeleteService RetrieveListRandomService RetrieveListUpdateDeleteService RetrieveListUpdateService UniversalGenericService Creating you custom generic service can be done as follows:\nuse Pionia\\Generics\\Base\\GenericService; class CreateRandomService extends GenericService { use CreateMixin, RandomMixin; }\rNow you can let you services extend this class and you will have the create and random actions available.\nuse application\\services\\CreateRandomService; class MyService extends CreateRandomService { public string $table = \u0026#39;users\u0026#39;; public array $createColumns = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;] }\rRemember you still need to register all these service as usual. In your request you can now call the create and random actions.\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;create_random\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;random\u0026#34;, \u0026#34;size\u0026#34;: 3 }\rThe above request will return 3 random records from the users table.\nGenericService inherits from BaseRestService which means that all the methods in the BaseRestService are available in the GenericService.\nRetrieveCreateUpdateService This generic service provides the retrieve, create and update actions.\nuse Pionia\\Generics\\Base\\RetrieveCreateUpdateService; class StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; public array $createColumns = []; }\rRetrieveListCreateService This generic service provides the retrieve, list and create actions.\nuse Pionia\\Generics\\Base\\RetrieveListCreateService; class StudentService extends RetrieveListCreateService { public string $table = \u0026#39;students\u0026#39;; public array $createColumns = []; }\rRetrieveListCreateUpdateDeleteService This generic service provides the retrieve, list, create, update and delete actions.\nuse Pionia\\Generics\\Base\\RetrieveListCreateUpdateDeleteService; class StudentService extends RetrieveListCreateUpdateDeleteService { public string $table = \u0026#39;students\u0026#39;; public array $createColumns = []; public ?array $updateColumns = null; }\rRetrieveListDeleteService This generic service provides the retrieve, list and delete actions.\nuse Pionia\\Generics\\Base\\RetrieveListDeleteService; class StudentService extends RetrieveListDeleteService { public string $table = \u0026#39;students\u0026#39;; }\rRetrieveListRandomService This generic service provides the retrieve, list and random actions.\nuse Pionia\\Generics\\Base\\RetrieveListRandomService; class StudentService extends RetrieveListRandomService { public string $table = \u0026#39;students\u0026#39;; }\rRetrieveListUpdateDeleteService This generic service provides the retrieve, list, update and delete actions.\nuse Pionia\\Generics\\Base\\RetrieveListUpdateDeleteService; class StudentService extends RetrieveListUpdateDeleteService { public string $table = \u0026#39;students\u0026#39;; public ?array $updateColumns = null; }\rRetrieveListUpdateService This generic service provides the retrieve, list and update actions.\nuse Pionia\\Generics\\Base\\RetrieveListUpdateService; class StudentService extends RetrieveListUpdateService { public string $table = \u0026#39;students\u0026#39;; public ?array $updateColumns = null; }\rUniversalGenericService This generic service provides all the actions. It is the most generic of all the generic services.\nuse Pionia\\Generics\\Base\\UniversalGenericService; class StudentService extends UniversalGenericService { public string $table = \u0026#39;students\u0026#39;; public array $createColumns = []; public ?array $updateColumns = null; public ?array $listColumns = [\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;]; public string $pk_field = \u0026#39;id\u0026#39;; }\rAll cases of retrieve can be replaced with details thus setting ACCTON in your request as details will still work the same as setting it to retrieve.\nCustomization $table This defines for us the table we are going to be interacting with. It is a required option.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; }\rAll the other services will require you to define this. This is the table that the service will be interacting with.\n$pk_field This defines the primary key field of the table. By default it is id. But you can override it to be any other field.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; public string $pk_field = \u0026#39;student_id\u0026#39;; }\r$createColumns This defines the columns that will be created when the create action is called. It is an array of strings.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; public ?array $createColumns = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;]; }\rAny other columns that are not defined in this array shall be ignored. This is requred for all create services.\n$updateColumns This defines the columns that will be updated when the update action is called. It is an array of strings.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; public ?array $updateColumns = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;]; }\rIf this is not defined, then all the columns that are defined in the request will be updated. This param is optional.\n$listColumns This defines the columns that will be returned for all actions that return data back to the end user. It is an array of strings.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; public ?array $listColumns = [\u0026#39;id\u0026#39;, \u0026#39;name\u0026#39;]; }\rThe above implies that whether we are hitting list, retrieve, random or any other action that returns data, only the id and name columns will be returned. This is optional and defaults to * if not defined.\n$limit This defines the size of records to return. It is an integer. It will henceforth be replaced by the LIMIT or limit on the request if it is defined or in the PAGINATION or pagination key in the request.\nBy default, this is set to 10 records.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; public int $limit = 10; }\r$offset This defines the offset where to start querying from. It is an integer. It will henceforth to be replaced by the OFFSET or offset on the request if it is defined or in the PAGINATION or pagination key in the request.\nBy default, this is set to 0 records.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; public int $offset = 0; }\rlimit or LIMIT and offset or OFFSET must both be defined on the request or in the PAGINATION or pagination or in the SEARCH or search key in the request for pagination to kick in, otherwise, each will perform its respective duty without pagination.\nOverriding Actions You can override any of the actions provided by the generic services. This is done by defining the action in the service.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; public function create(): BaseResponse { // Your custom logic here $data = $this-\u0026gt;request-\u0026gt;getData(); // perform your own way of creating the record return BaseResponse::JsonResponse(0, \u0026#34;your message\u0026#34;, $data); } }\rThe fact that Pionia is structured in an OOP way, you can override any of the actions provided by the generic services. This is just normal PHP OOP inheritance.\nAdding Custom Actions You can add your own custom actions to the generic services. This is done by defining the action in the service.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; public function customAction(): BaseResponse { // Your custom logic here $data = $this-\u0026gt;request-\u0026gt;getData(); // perform your own custom action return BaseResponse::JsonResponse(0, \u0026#34;your message\u0026#34;, $data); } }\rYou can now call this action in your request by setting the ACTION key to custom_action.\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;student\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;custom_action\u0026#34; }\rThe name of your custom action must not conflict with any of the actions provided by the generic services. Otherwise you stand a chance of overriding the generic action.\nOverriding getters You can also tell the service how to query one item and how to list multiple items. This is can be handy where for example you want to add complex where clauses to your queries.\nFor this cause, you can override the getItem and getItems methods in service.\nclass StudentService extends RetrieveCreateUpdateService { public string $table = \u0026#39;students\u0026#39;; /** * Override this in your service to define the basis to return single item details * @return null|object */ public function getItem(): ?object { return null; } /** * Override this in your service to define the basis to return multiple items from the database * @return null|object */ public function getItems(): ?array { return null; } }\rGeneric Services Signals(Hooks) Generic Services come baked with hooks that enable you to run custom code before or after the CRUD operations. The following are some of these hooks:\npreCreate This hook is called before the create action is executed.\npublic function preCreate(?array $createItem = null): array|bool|null { if ($createItem) { $createItem[\u0026#39;title\u0026#39;] = $createItem[\u0026#39;title\u0026#39;] . \u0026#34; - \u0026#34; . date(\u0026#39;Y-m-d H:i:s\u0026#39;); } return $createItem; }\rIf this hook returns null or a false value, the create action will abort.\nAlso, this hook has access to the createItem that is about to be created. You can mutate data as you see fit at this point or add extra data.\nOn success, hooks must return the createItem that will be used to create the record.\npostCreate This hook is called after the create action is executed.\npublic function postCreate(object|array|null $createdItem = null): object|array|null { $createdItem-\u0026gt;created = true; return $createdItem; }\rIt gives you access to the currently create record. You can mutate the return data as you see fit, but this won\u0026rsquo;t affect the object that has already been saved. This is just for the response.\nWhatever object or array you return from here is what shall be sent back to the user.\npreUpdate This hook is called before the update action is executed.\npublic function preUpdate(?array $updateItem = null): array|bool|null { if ($updateItem) { $updateItem[\u0026#39;title\u0026#39;] = $updateItem[\u0026#39;title\u0026#39;] . \u0026#34; - \u0026#34; . date(\u0026#39;Y-m-d H:i:s\u0026#39;); } return $updateItem; }\rIf this hook returns null or a false value, the update action will abort.\nAlso, this hook has access to the updateItem that is about to be updated. You can mutate data as you see fit at this point or add extra data.\nThe object that is returned from this hook is what shall be used to update the record.\npostUpdate This hook is called after the update action is executed.\npublic function postUpdate(object|array|null $updatedItem = null): object|array|null { $updatedItem-\u0026gt;updated = true; return $updatedItem; }\rIt gives you access to the currently updated record. You can mutate the return data as you see fit, but this won\u0026rsquo;t affect the object that has already been saved. This is just for the response.\nWhatever object or array you return from here is what shall be sent back to the user.\npreDelete This hook is called before the delete action is executed.\npublic function preDelete(object|array|null $itemToDelete = null): array|null|object|bool { if ($itemToDelete-\u0026gt;id \u0026gt; 10){ return false; } return $itemToDelete; }\rIf this hook returns null or a false value, the delete action will abort. Otherwise, the $itemToDelete will be deleted.\nThe hook also gives you access to the item to be deleted. You can perform any conditions or any other logic you see fit.\npostDelete This hook is called after the delete action is executed.\npublic function postDelete(PDOStatement $deleteInstance, object|array|null $deletedItem = null): mixed { return $deletedItem; }\rHowever much the record is nolonger in the db, this hook gives you access to the record that was deleted. You can use it as you see fit. The object that is returned from this hook is what shall be sent back to the user.\nWhy would you need these hooks? Hooks can be used to mutate data before it is saved to the database. Hooks can be used to transform the response back to the user to meet your needs. It is in these hooks where you have a chance to log, send emails or do any other action that is not directly related to the CRUD operation. The hooks are not to be used outside services that extend the GenericService class. They are already included in the generic services.\nSecuring Generic Services. The fact that Generic Services extend BaseRestService means that all authentication and authorization checks are still in place.\nYou can still use $serviceRequiresAuth to protect the entire service from unauthenticated access.\npublic bool $serviceRequiresAuth = true;\rYou can also define a few actions that will require authentication like below.\npublic ?array $actionsRequiringAuth = [\u0026#39;create\u0026#39;, \u0026#39;update\u0026#39;, \u0026#39;delete\u0026#39;];\rYou can also protect actions by permissions using the $actionPermissions property.\npublic ?array $actionPermissions = [ \u0026#39;create\u0026#39; =\u0026gt; [\u0026#39;create_student\u0026#39;], \u0026#39;update\u0026#39; =\u0026gt; [\u0026#39;update_student\u0026#39;], ];\rThis will ensure that only users with the listed permissions can access the action.\nPlease note that the permissions are represented as an array not a string.\nConclusion The generic services are there to help you with the CRUD operations. They are there to help you focus on the complex business logic.\nYou can use the mixin to come up with your own custom generic services. You can also override the actions provided by the generic services.\nThis is all to turbo charge your development process which is the main goal of Pionia.\n", "date": "2024-06-29", "id": 13, "permalink": "/documentation/services/generic-services/", "summary": "All business logic in Pionia is stored in services. This guide will show you how to create, protect and use services in Pionia.", "tags": [], "title": "Generic Services" },
  { "content": "\rThis section assumes that you have a basic understanding how Generic Services work in Pionia. If you haven\u0026rsquo;t, you can check the Generic Services section first.\nIntroduction Pionia Generic Services can be used to do more than just CRUD operations. This section is also still growing immensely as we discover more ways to use Generic Services. In this section, we will look at how to use Generic Services for more advanced operations.\nRelationships The first advanced operation we will look at is relationships. Pionia Generic Services can now query relationships directly.\nRemember that Pionia as the framework does not have a built-in Model Layer. Therefore, generic services are the best way to interact with related data.\nProperties and Methods This feature is only available in all services that extend the Pionia\\Services\\GenericService class. But by default, this feature is not activated. You have to defines some or all of the following properties and methods to activate it.\n$joins The $joins property is an array defining each table we are connecting to and the relationship between them.\nRemember, that we still need our base table to be defined in the $table property.\npublic string $table = \u0026#39;products\u0026#39;; public array $joins = [ \u0026#39;category\u0026#39; =\u0026gt; [\u0026#39;id\u0026#39; =\u0026gt; \u0026#39;category_id\u0026#39;] ];\rThe above implies that we have a products table and a category table. The products table has a category_id column that relates to the id column in the category table.\n$joinTypes For each table in the $joins property, we can define the type of join to use.\npublic array $joinTypes = [ \u0026#39;category\u0026#39; =\u0026gt; JoinType::INNER ];\rIf you had defined an alias on your table, you can define the $joinAlias property to use the alias in the query.\npublic ?array $joinAliases = [ \u0026#39;category\u0026#39; =\u0026gt; \u0026#39;cat\u0026#39;, ];\rThis implies that the category table will be aliased as cat in the query. This has to be reflected in all queries that use the category table including in the $listColumns property.\npublic ?array $listColumns = [ \u0026#39;product.id(id)\u0026#39;, \u0026#34;product.name(product_name)\u0026#34;, \u0026#34;cat.name(category_name)\u0026#34;, \u0026#34;cat.created_at(category_created_at)\u0026#34;, \u0026#34;product.created_at(product_created_at)\u0026#34;, \u0026#34;active\u0026#34; ];\rAS Clause In the entire Porm including even in the above listColumns property, you can achieve the AS clause to alias columns by using the () syntax.\npublic ?array $listColumns = [ \u0026#39;product.id(id)\u0026#39;, // product.id AS id \u0026#34;product.name(product_name)\u0026#34;, // product.name AS product_name \u0026#34;cat.name(category_name)\u0026#34;, // cat.name AS category_name \u0026#34;cat.created_at(category_created_at)\u0026#34;, // cat.created_at AS category_created_at \u0026#34;product.created_at(product_created_at)\u0026#34;, // product.created_at AS product_created_at \u0026#34;active\u0026#34; ];\rThis is applicable to all use cases of Porm.\nCreation Even in cross relationships, you are only allowed to insert in the base table. This means saving across relationships is not yet supported.\nUploading Files Pionia Generic Services have a built-in file upload feature. This is done by defining the $fileColumns property.\nImagining the following $createColumns:-\npublic ?array $createColumns = [ \u0026#39;name\u0026#39;, \u0026#39;active\u0026#39;, \u0026#39;icon_image\u0026#39;, ];\rIf you want the icon_image to be treated as a file upload, you can define the $fileColumns property as follows:-\npublic ?array $fileColumns = [ \u0026#39;icon_image\u0026#39; ];\rThis will automatically upload the file and save the file path in the database.\nBy default, this behaviour uploads the file to the media directory in the root of your project. But you can change this in your settings.ini file by defining the uploads section.\n[uploads] media_dir=/media media_url=/media max_size=20000000\rFrom the above, the media_dir is the directory where the files will be uploaded to. The media_url is the URL to access the files. The max_size is the maximum size of the file to be uploaded.\nCustom upload handler If you don\u0026rsquo;t want to upload files to the media directory, you can define a custom upload handler by overriding the handleUpload method.\nThis method receives the UploadedFile object as the first argument and the fileName as the second argument.\nThe fileName matches the parameter that was used to receive the file in your action, in the example above it would be icon_image.\n/** * Provides the default upload behaviour for the service. * * You can override this method in your service to provide custom upload behaviour. * @param UploadedFile $file The file to upload * @param string $fileName The name to save the file as * @throws Exception */ public function handleUpload(UploadedFile $file, string $fileName): mixed { return $this-\u0026gt;defaultUpload($file, $fileName); }\rThis is the core default implementation of the handleUpload method. Once this is defined in your service, all files will be uploaded using your custom handler.\nThe handleUpload method should return the path to the file to be saved in the database. Whatever it returns, we will attempt to save it in the database.\nQuerying Relationships This is the part where generic services shine the most. The frontend now has access to all the related data. So they can even define the columns across relationships defined above to return from the db.\nIf the frontend want to withdraw from querying relationships back to querying the base table, they can define the dontRelate request parameter as true.\n{ // other parameters, \u0026#34;dontRelate\u0026#34;: true }\rThe frontend can also define the COLUMNS parameter to define the columns to return from the base table.\n{ // other parameters, \u0026#34;COLUMNS\u0026#34;: [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;] }\rIf your tables are aliased, you can use the alias in the COLUMNS parameter.\n{ // other parameters, \u0026#34;COLUMNS\u0026#34;: [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;cat.name\u0026#34;] }\rAlso, the frontend can achieve the AS clause by using the () syntax.\n{ // other parameters, \u0026#34;COLUMNS\u0026#34;: [\u0026#34;product.id(id)\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;cat.name(category_name)\u0026#34;] // product.id AS id, name, cat.name AS category_name }\rAll the other functionalities of the Generic Services are still available in the advanced operations.\nWhen switching from relationships back to querying the base table alone, Pionia takes care of converting the listColumns however, if you had aliased your tables, you need to remember how you named your pk_field as it might no longer be id.\n", "date": "2024-06-29", "id": 14, "permalink": "/documentation/services/advanced-generic-services/", "summary": "Pionia Generic Services can be used for more than CRUD operations. This guide shows you how to use them.", "tags": [], "title": "Advanced Generic Services" },
  { "content": "\rHandling Requests and Responses In Pionia all actions take up request data as associated array, and return a BaseResponse object. This guide will show you how to handle requests and responses in pionia.\nRequest Pionia framework supports only HTTP verbs due to its single endpoint nature. The supported HTTP verbs are:\nGET This is used to ping api endpoints for every api version you roll out. This implies that every time you create a new switch, you get this action for free. GET Request\nRemember all switches are matching a certain version of your api. The default MainApiSwitch matches v1 of your api.\nIf you want to ping the v1 of your api, you can use the GET request.\nGET http://localhost:8000/api/v1/\rThis will respond with the following:\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;pong\u0026#34;, \u0026#34;returnData\u0026#34;: { \u0026#34;framework\u0026#34;: \u0026#34;Pionia\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.1.7\u0026#34;, \u0026#34;port\u0026#34;: 8000, \u0026#34;uri\u0026#34;: \u0026#34;/api/v1/\u0026#34;, \u0026#34;schema\u0026#34;: \u0026#34;http\u0026#34; }, \u0026#34;extraData\u0026#34;: null }\rThis is the only use of the GET verb in Pionia. All other actions are done using the POST verb.\nPOST Every request you make to Pionia is POST. This is because Pionia is a single endpoint framework.\nSo for all the examples that will be mentioned below, you will assume the POST verb.\nEndpoint The endpoint is the URL where your api is hosted. In Pionia, the endpoint is the same for every version of your api. The only thing that changes is the request body. Each switch matches an endpoint. The default MainApiSwitch matches the /api/v1/ endpoint.\nAll switches alongside their versions are registered in the routes.php file. This file is located in the app directory.\nThe highligted code below shows how the MainApiSwitch is registered in the routes.php file. If no version is defined, then Pionia assumes v1 as the default version.\napp/routes.php\r1\u0026lt;?php 2 3use Pionia\\Core\\Routing\\PioniaRouter; 4 5$router = new PioniaRouter(); 6 7$router-\u0026gt;addSwitchFor(\u0026#34;application\\switches\\MainApiSwitch\u0026#34;); 8 9return $router-\u0026gt;getRoutes();\rTo add a second version of the api, you can add a new switch and register it in the routes.php file.\napp/routes.php\r1\u0026lt;?php 2use Pionia\\Core\\Routing\\PioniaRouter; 3 4$router = new PioniaRouter(); 5 6$router-\u0026gt;addSwitchFor(\u0026#34;application\\switches\\MainApiSwitch\u0026#34;) 7 -\u0026gt;addSwitchFor(\u0026#34;application\\switches\\SecondApiSwitch\u0026#34;, \u0026#34;v2\u0026#34;); 8 9return $router-\u0026gt;getRoutes();\rThis will register the SecondApiSwitch to the /api/v2/ endpoint.\nNote\nThis also implies that all switches registered in the routes.php originate from the /api/ endpoint.\nThis is all you need to know about Pionia Routing!\nRequest Data Pionia supports both JSON and FormData data. Whereas using both is possible, it is recommended to use JSON data unless you are uploading files.\nEvery action has access to the request data as an associated array. This data is passed to the action as the first argument.\n\u0026lt;?php public function action(array $data): BaseResponse { // your code here }\rYou can access the data in the action as shown below:\n\u0026lt;?php public function action(array $data): BaseResponse { $name = $data[\u0026#39;name\u0026#39;]; $email = $data[\u0026#39;email\u0026#39;]; // your code here }\rHowever, the above data won\u0026rsquo;t include the files if you are uploading files, you can access them from the second parameter $files.\nNote\nThe files parameter is a symfony FileBag object. A file bag is generally a collection of uploaded files.\nTo get one file from the file bag, you can use the get method.\npublic function action(array $data, FileBag $files): BaseResponse { $file = $files-\u0026gt;get(\u0026#39;file\u0026#39;); $name = $data[\u0026#39;name\u0026#39;]; $email = $data[\u0026#39;email\u0026#39;]; // your code here }\rMarking Request Data as required In your action you can define data that must be present in the request. This is done by calling the requires method on the service instance.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;requires([\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;]); $name = $data[\u0026#39;name\u0026#39;]; $email = $data[\u0026#39;email\u0026#39;]; // your code here }\rThis will check if the $data array or the $files FileBag contains the name and email keys. If any of the keys are missing, the action will abort.\nYou can also use the method to check one key at a time.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;requires(\u0026#39;name\u0026#39;); // can be a string too $name = $data[\u0026#39;name\u0026#39;]; $email = $data[\u0026#39;email\u0026#39;]; // your code here }\rWhereas you can use the requires method on a single key, you should always prefer checking all your keys at once using an array.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;requires([\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;]); $name = $data[\u0026#39;name\u0026#39;]; $email = $data[\u0026#39;email\u0026#39;]; // your code here }\rValidating Request Data Pionia provides a simple way to validate request data. Helper methods are already available on the service instance.\nFor all the helper methods provided, you can override the underlying regex pattern by passing a custom pattern as the second argument.\nEmail \u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asEmail($data[\u0026#39;email\u0026#39;]); // your code here }\rURL \u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asUrl($data[\u0026#39;url\u0026#39;]); // your code here }\rIP \u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asIp($data[\u0026#39;ip\u0026#39;]); // your code here }\rSlug \u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asSlug($data[\u0026#39;slug\u0026#39;]); // your code here }\rInternational Phone Number You can also validate international phone numbers. The second argument is the country code you want to validate against. This is optional.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asPhoneNumber($data[\u0026#39;phone\u0026#39;], \u0026#39;+254\u0026#39;); // your code here }\rPassword Strong Passwords have rules that they must adhere to. You can validate passwords using the asPassword method. Rules considered are:\nAt least one uppercase letter At least one lowercase letter At least one digit At least one special character At least 8 characters long \u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asPassword($data[\u0026#39;password\u0026#39;]); // your code here }\rNumber This checks for both Integers and Floats.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asNumber($data[\u0026#39;number\u0026#39;]); // your code here }\rNumeric This checks for numbers and numbers in string format.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asNumeric($data[\u0026#39;numeric\u0026#39;]); // your code here }\rNumeric Integers This checks for integers and integers in string format.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asNumericInt($data[\u0026#39;int\u0026#39;]); // your code here }\rMac Address \u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asMac($data[\u0026#39;mac\u0026#39;]); // your code here }\rDomain \u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;asDomain($data[\u0026#39;domain\u0026#39;]); // your code here }\rShould Be This is a special method that allows you to define a custom validation. The second argument can be a regex or anything to match.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;shouldBe($data[\u0026#39;custom\u0026#39;], \u0026#39;/^([a-zA-Z0-9\\s_\\\\.\\-:])+$/\u0026#39;); // your code here }\rAll Should Be Checks if all the keys in the array are valid. The second argument is the validation method to use.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;allShouldBe($data, \u0026#39;/^([a-zA-Z0-9\\s_\\\\.\\-:])+$/\u0026#39;); // your code here }\rCustom Validation You can also define a custom validation using the validate method. The method should return a boolean or int.\n\u0026lt;?php public function action(array $data): BaseResponse { $this-\u0026gt;validate(string $regex, mixed $data, $message = \u0026#39;Invalid data\u0026#39;); // your code here }\rResponse All responses that hit the application server return a 200 OK status code. And as a result, Pionia returns back the power to define the return code of the response. This is done by returning a BaseResponse object.\nPionia returns a BaseResponse object for every action. This object is used to send responses back to the client.\nThis response consists of the following fields:\nreturnCode: This is the return code of the response. It is an integer and is required. returnMessage: This is the return message of the response. It is a string or null. returnData: This is the return data of the response. It is an array or null. extraData: This is any extra data you want to send back. It is an array or null. Exceptions In Pionia, wherever you\u0026rsquo;re, you can throw an exception. This will be caught by the framework and the response will be sent back to the client.\nTherefore, to abort any action or task on going, you can just throw an exception with clear message.\n\u0026lt;?php public function action(array $data): BaseResponse { throw new Exception(\u0026#39;This is an exception message that will stop this action from proceeding\u0026#39;); }\rNote\nBy default, Pionia reserves returnCode of 0 for successful responses. This is just a convention, and you can use any other code you want.\n", "date": "2024-05-24", "id": 15, "permalink": "/documentation/requests-and-responses/", "summary": "All actions take up request data as associated array, and return a BaseResponse object. This guide will show you how to handle requests and responses in pionia.", "tags": [], "title": "Requests and Responses" },
  { "content": "\r", "date": "2023-09-07", "id": 16, "permalink": "/docs/documentation/", "summary": "\r", "tags": [], "title": "Documentation" },
  { "content": "\r", "date": "2023-09-07", "id": 17, "permalink": "/docs/documentation/security/", "summary": "\r", "tags": [], "title": "Security" },
  { "content": "\rThis guide assumes you have a basic understanding of how Pionia works. If you are new to Pionia, you can start by going through the API Tutorial guide.\nSecurity is a very important aspect of any application. In Pionia, Security is approached in two ways.\nAuthentication Authorization Authentication - Authentication Backends. Currently, Pionia does not dictate on any authentication mechanism but provides a way to implement your own authentication mechanism.\nPionia keeps an open mind on how you want to secure your apis. Most commonly, you will find JWT, OAuth, Basic Auth, and many more helpful. You can implement any of these in Pionia. All Pionia is seeking out is context user object that gets returned in your authentication backends.\nWith this approach, you can make authentication backends that handle mobile, web, and other platforms separately.\nPackages like firebase/php-jwt can be used to implement JWT authentication.\nAlso, you can visit our jwt authentication sample guide on how to implement JWT authentication in Pionia.\nAbout Authentication Backends These are classes that are responsible for authenticating the user. They are responsible for verifying the user\u0026rsquo;s identity and returning the user object.\nAll authentication backends must extend the Pionia\\Core\\Interceptions\\BaseAuthenticationBackend class and implement the authenticate method. This method receives the request object, this also implies that you have access to your headers, request body, and therefore you can implement any authentication mechanism you want.\nAuthentication backends must return the Pionia\\Core\\Helpers\\ContextUserObject object if the user is authenticated, otherwise, they should return null.\nYou can have multiple authentication backends in the same application. Pionia will iterate through all the authentication backends until one of them returns a user object.\nOtherwise, it will proceed to process the request without authenticating the user. And as a result, this-\u0026gt;mustAuthenticate will be failing if the user is not authenticated.\nCreating an Authentication Backend To quickly bootstrap your authentication backend, you can use the following command.\nExample below creates an authentication backend called JwtAuthBackend.\nphp pionia gen:auth jwt\rNotice that we only define jwt as the authentication backend name. This is because Pionia will automatically append AuthBackend to the name.\nUpon running the above command, Pionia will create a new authentication backend in the app/authentications directory.\n\u0026lt;?php /** * This authentication backend is auto-generated from pionia cli. * Remember to register your backend in settings.ini */ namespace application\\authentications; use Pionia\\Core\\Helpers\\ContextUserObject; use Pionia\\Core\\Interceptions\\BaseAuthenticationBackend; use Pionia\\Request\\Request; class JwtAuthBackend extends BaseAuthenticationBackend { /** * Implement this method and return your \u0026#39;ContextUserObject\u0026#39;. You can use Porm here too! */ public function authenticate(Request $request):? ContextUserObject { $userObj = new ContextUserObject(); # your logic here... return $userObj; } }\rYou can now implement your authentication logic in the authenticate method.\nTo access the headers, you can get them from the headers key on the request like $authHeader = $request-\u0026gt;headers-\u0026gt;get('Authorization');.\nThe ContextUserObject is a simple object that holds the user\u0026rsquo;s information. You can add any information you want to this object.\nIt contains the following properties:\nuser - The object from your db. authenticated - A boolean value that indicates whether the user is authenticated or not. permissions - An array of permissions that the user has. authExtra - Any other extra data you want to set on the user context. This can store staff like role, user id, etc. You will be able to access this data in your services. Registering your Authentication Backend After creating your authentication backend, you need to register it in the settings.ini file under the authentications section. Every backend must be given a unique name. Also, you to note that the order of registration matters. Pionia will iterate through the authentications in the order they are registered.\n[authentications] jwt_auth = application\\authentications\\JwtAuthBackend\rAnd that\u0026rsquo;s it! Your authentication backend is now ready to be used in your application.\nRBAC - Service Level Authorization Accessing the set Context Object To access the context object in your services, you can access it from the $this-\u0026gt;auth();.\nThis returns the ContextUserObject object that you set in your authentication backend.\n\u0026lt;?php class TodoService extends BaseRestService { public function getTodo() { $user = $this-\u0026gt;auth()-\u0026gt;user; $permissions = $this-\u0026gt;auth()-\u0026gt;permissions; $authExtra = $this-\u0026gt;auth()-\u0026gt;authExtra; // your logic here... } }\rAccessing the AuthExtras AuthExtras are an associative array that you can use to store any extra data you want to access in your services. To access a single item from this array, you can use $this-\u0026gt;getAuthExtraByKey($key).\nYou can also check if a certain extra key was set on the extras array by using $this-\u0026gt;authExtraHas($key). This will return a boolean value.\n\u0026lt;?php class TodoService extends BaseRestService { public function getTodo() { $role = $this-\u0026gt;getAuthExtraByKey(\u0026#39;role\u0026#39;); $userId = $this-\u0026gt;getAuthExtraByKey(\u0026#39;userId\u0026#39;); // your logic here... } }\rProtecting your Services The entire service can be protected by setting the $serviceRequiresAuth property to true. This will ensure that all actions in the service are secure and only authenticated users can access them.\n\u0026lt;?php class TodoService extends BaseRestService { protected $serviceRequiresAuth = true; public function getTodo() { // your logic here... } }\rProtecting your Actions You can also protect individual actions in two ways.\nSetting the $actionsRequiringAuth property You can set the $actionsRequiringAuth property to an array of actions that require authentication.\nclass TodoService extends BaseRestService { protected $actionsRequiringAuth = [\u0026#39;getTodo\u0026#39;]; public function getTodo() // accessing this action will require authentication { // your logic here... } }\rUsing the mustAuthenticate method You can also use the mustAuthenticate method in your action to check if the user is authenticated. This method will throw an exception if the user is not authenticated.\nclass TodoService extends BaseRestService { public function getTodo() { $this-\u0026gt;mustAuthenticate(); // user must be authenticated to go beyond this point // your logic here... } }\rSetting the $authMessage property will set a custom message that will be thrown if the user is not authenticated.\nclass TodoService extends BaseRestService { protected $authMessage = \u0026#39;You must be authenticated to use any service in the todo context.\u0026#39;; public function getTodo() { $this-\u0026gt;mustAuthenticate(); // user must be authenticated to go beyond this point // your logic here... } }\rAuthorization Authorization is the process of determining whether a user has the necessary permissions to access a certain resource.\nIn Pionia, authorization is done using permissions. Permissions are authorization rules that you can set on your context object in your authentication backend.\nPermissions - Authorities There are three ways to check if a user has a certain permission[s]/authority[ies].\nUsing the $actionPermission service property. This can be used both in the normal and in generic services. It defines an associative array that defines permission list per action.\npublic array $actionPermissions = [ \u0026#39;create\u0026#39; =\u0026gt; [\u0026#39;create_todo\u0026#39;], \u0026#39;update\u0026#39; =\u0026gt; [\u0026#39;update_todo\u0026#39;], \u0026#39;delete\u0026#39; =\u0026gt; [\u0026#39;delete_todo\u0026#39;] ];\rFrom Version 1.1.4, this can also take up strings like below\npublic array $actionPermissions = [ \u0026#39;create\u0026#39; =\u0026gt; \u0026#39;create_todo\u0026#39;, \u0026#39;update\u0026#39; =\u0026gt; \u0026#39;update_todo\u0026#39;, \u0026#39;delete\u0026#39; =\u0026gt; \u0026#39;delete_todo\u0026#39; ];\rPermissions create_todo, update_todo are permissions you set on the context user object from your authentication backends. If these are not defined, the service won\u0026rsquo;t be accessed.\nThe above implies that to access\nUsing the can method You can check if a user has a certain permission by using the can method that is available on the service.\n\u0026lt;?php class TodoService extends BaseRestService { public function getTodo() { $this-\u0026gt;can(\u0026#39;view-todo\u0026#39;); // user must have the permission to go beyond this point } }\rIf the user does not have the permission, the can method will throw an exception and the action will not be executed.\nUsing the canAll method can checks only one permission, however, you can check multiple permissions by using the canAll method.\n\u0026lt;?php class TodoService extends BaseRestService { public function getTodo() { $this-\u0026gt;canAll([\u0026#39;view-todo\u0026#39;, \u0026#39;edit-todo\u0026#39;]); // user must have both permissions to go beyond this point } }\rUsing the canAny method The two methods mentioned earlier check if the user has the permission. However, you might want to check if the user has any one of the permissions. You can do this by using the canAny method.\nclass TodoService extends BaseRestService { public function getTodo() { $this-\u0026gt;canAny([\u0026#39;view-todo\u0026#39;, \u0026#39;edit-todo\u0026#39;]); // user must have any of the permissions to go beyond this point } }\rCustom Authorization Messages The above methods take a second parameter $message which is a custom message that will be thrown if the user does not have the permission.\nclass TodoService extends BaseRestService { public function getTodo() { $this-\u0026gt;can(\u0026#39;view-todo\u0026#39;, \u0026#39;You do not have permission to view todo\u0026#39;); // user must have the permission to go beyond this point } }\rAll the authentication and authorization should happen early in the an action. This is because, if the user is not authenticated or does not have the necessary permissions, the action should not be executed.\nRemember, all authentication backends run after middlewares. This is because middlewares can be used to sanatize the request, and therefore, it is important to run them before the authentication backends.\nCustom Return Codes. By default, Pionia will return a 401 return code if the user is not authenticated and a 403 return code if the user does not have the necessary permissions.\nYou can override these permissions by defining the UNAUTHENTICATED_CODE and the UNAUTHORIZED_CODE in the settings.ini under the SERVER section.\n[SERVER] ; other settings UNAUTHENTICATED_CODE = 10 UNAUTHORIZED_CODE = 11 ; other settings\rUsing the above example, 10 and 11 will override the default 401 and 403 return codes respectively.\n", "date": "2024-06-29", "id": 18, "permalink": "/documentation/security/security-authentication-and-authorization/", "summary": "Authentication and Authorization are two important aspects of security in any application. This guide will show you how to secure your application using pionia.", "tags": [], "title": "Security - Authentication and Authorization" },
  { "content": "\rThis guide assumes you have a basic understanding of how Pionia Security works. If you are new to Pionia, you can start by going through the API Tutorial guide.\nOur target Our target is to create a simple authentication system using JWT. We will use the Firebase/JWT package to illustrate how to create a simple authentication system.\nThis authentication should be able to intercept every request and attempt to authenticate the user.\nInstallation We need the Firebase/JWT package to create our authentication system. You can install the package via composer.\ncomposer require firebase/php-jwt\rRequirements You should have a database table called system_user with the following columns:\nPostgres ddl\rcreate table public.system_user ( first_name varchar, last_name varchar, password varchar not null, email varchar not null, username varchar, role_code varchar, created_at timestamp default now(), last_logged_in_at timestamp, is_active boolean default false, id bigserial constraint system_user_pk primary key );\rFor this tutorial, we shall be using PostgreSQL as our database.\nBootstrapping our Authentication Backend Pionia provides to Bootstrap our authentication backend using the Pionia CLI. You can run the following command to create the authentication backend.\nphp pionia gen:auth jwt\rThis will create the authentications folder if it doesn\u0026rsquo;t exist and create the jwt authentication backend in the same folder.\nAfter this, you should have the following files in your authentications directory:\napp ├──authentications/ ├── JwtAuthenticationBackend.php\rAnd the above class should look like this:\n\u0026lt;?php /** * This authentication backend is auto-generated from pionia cli. * Remember to register your backend in index.php. */ namespace application\\authentications; use Pionia\\Core\\Helpers\\ContextUserObject; use Pionia\\Core\\Interceptions\\BaseAuthenticationBackend; use Pionia\\Request\\Request; class JwtAuthBackend extends BaseAuthenticationBackend { /** * Implement this method and return your \u0026#39;ContextUserObject\u0026#39;. You can use Porm here too! */ public function authenticate(Request $request): ?ContextUserObject { $userObj = new ContextUserObject(); # your logic here... return $userObj; } } Let\u0026rsquo;s first leave this file as it is and create a new file JwtUtility.php in the utils directory. We shall get back to it.\nFor separation of concerns, let\u0026rsquo;s create a utils directory where we shall drop all utility classes for our app.\nCreate a new file JwtUtility.php in the same utils directory.\napp ├──utils/ ├── JwtUtility.php\rIn the JwtUtility.php file, add the following code:\nJwtUtility.php\r\u0026lt;?php namespace application\\utils; use Exception; use Firebase\\JWT\\JWT; use Firebase\\JWT\\Key; use Pionia\\Core\\Pionia; use Pionia\\Exceptions\\UserUnauthenticatedException; use Porm\\Database\\builders\\Where; use Porm\\Porm; use stdClass; class JwtUtility { /** * get the JWT settings from our settings.ini * */ public function jwtSettings() : array { return pionia::getSetting(\u0026#39;JWT\u0026#39;); } /** * We grab a user from the database where either username or email is equivalent to the provided * If we don\u0026#39;t want to return the password hash, we pass false as the second param * @throws Exception */ public static function getUserByUsername(string $username, ?bool $withPassword = true): object { $columns = \u0026#34;*\u0026#34;; // we define all the columns we need to return except the password hash if (!$withPassword) { $columns = [ \u0026#34;id\u0026#34;, \u0026#34;first_name\u0026#34;, \u0026#34;last_name\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;role_code\u0026#34;, \u0026#34;created_at\u0026#34;, \u0026#34;last_logged_in_at\u0026#34;, \u0026#34;is_active\u0026#34; ]; } $user = Porm::table(\u0026#34;system_user\u0026#34;) -\u0026gt;columns($columns)-\u0026gt;get(Where::builder()-\u0026gt;or([\u0026#39;email\u0026#39; =\u0026gt; $username, \u0026#39;username\u0026#39; =\u0026gt; $username])-\u0026gt;build()); if (!$user){ throw new UserUnauthenticatedException(\u0026#34;User not found\u0026#34;); } if (!$user-\u0026gt;is_active){ throw new UserUnauthenticatedException(\u0026#34;User account is not active\u0026#34;); } return $user; } /** * Generates the jwt token and updates the user\u0026#39;s last login date * @throws Exception */ public function generateToken(object $user): string { $expiresAt = $this-\u0026gt;jwtSettings()[\u0026#39;expires_at\u0026#39;]; $secretKey = $this-\u0026gt;jwtSettings()[\u0026#39;secret_key\u0026#39;]; $iat = time(); $eat= $iat + $expiresAt; $payload = [ \u0026#34;iss\u0026#34; =\u0026gt; pionia::$name, \u0026#34;iat\u0026#34; =\u0026gt; $iat, \u0026#34;exp\u0026#34; =\u0026gt; $eat, \u0026#34;sub\u0026#34; =\u0026gt; $user-\u0026gt;username, ]; $token = JWT::encode($payload, $secretKey, \u0026#39;HS256\u0026#39;); // if we have our token, we populate the last login time for this user if ($token) { Porm::table(\u0026#34;system_user\u0026#34;) -\u0026gt;update([\u0026#39;last_logged_in_at\u0026#39; =\u0026gt; date(\u0026#34;m/d/Y H:i:s\u0026#34;, $iat)], $user-\u0026gt;id); } return $token; } /** * Decodes any jwt token using our secret_key with a leeway of only 60 seconds * @param string $token * @return stdClass */ public function decodeToken(string $token): stdClass { $key = $this-\u0026gt;jwtSettings()[\u0026#39;secret_key\u0026#39;]; JWT::$leeway = 60; // 60 secs -- to cater for clock skew times between the signing and verifying servers return JWT::decode($token, new Key($key, \u0026#39;HS256\u0026#39;)); } }\rWhat do we have here? We have a JwtUtility class that handles all our JWT logic.\ngetUserByUsername method fetches a user by username or email from the database. It also checks if the user is active. If the user is not found or not active, it throws an exception. In normal circumstances, this method returns everything from the system_user table, including the password hash. However, if $withPassword is set to false, it returns everything except the password hash. This is useful when you want to return the user object to the client.\njwtSettings method returns the JWT settings from the settings.ini file.\ngenerateToken method generates a JWT token for the user. It fetches the user by username, generates a token, and updates the last login date in the database.\ndecodeToken method decodes the token and returns the decoded token.\nWe shall use this utility class in our JwtAuthenticationBackend.php file and in our login action.\nIn our JwtAuthenticationBackend.php in the authentications folder, replace the authenticate method with the following code:\nJwtAuthenticationBackend.php\r/** * Gets the authorization header from the request and authenticates with the provided token * If everything is okay, the context user is returned and Pionia will take over from here. * @throws Exception */ public function authenticate(Request $request): ?ContextUserObject { $authorizationHeader = $request-\u0026gt;headers-\u0026gt;get(\u0026#34;Authorization\u0026#34;); if (!$authorizationHeader){ return null; } $jwtUtility = new JwtUtility(); $bearerKey = $jwtUtility-\u0026gt;jwtSettings()[\u0026#39;bearer_key\u0026#39;] ?? \u0026#39;Bearer\u0026#39;; // check if our token starts with the above key if (!str_starts_with($authorizationHeader, $bearerKey)){ return null; } // grab the token alone removing the \u0026#34;Bearer \u0026#34; part $token = trim(str_replace($bearerKey, \u0026#39;\u0026#39;, $authorizationHeader)); $decoded = $jwtUtility-\u0026gt;decodeToken($token); $username = $decoded-\u0026gt;sub; $user = $jwtUtility::getUserByUsername($username); // since we have our context user, we can populate them from here $contextUser = new ContextUserObject(); $contextUser-\u0026gt;user = $user; $contextUser-\u0026gt;authenticated = true; $contextUser-\u0026gt;authExtra[\u0026#34;role\u0026#34;] = $user-\u0026gt;role_code; // we have no permissions, so we ignore the permissions key return $contextUser; }\rWhat do we have here? We get the Authorization header from the request. We get the bearer_key from the settings.ini file. This is to make it easy to change the name of the Authorization header. We check if the Authorization header is empty or does not start with the bearer_key. If it does not, we return null and the request will proceed but unauthenticated. Otherwise, we create a new ContextUserObject and decode the token. We then fetch the user by username and set the authenticated property to true and the user property to the user object we got from the database. We return the ContextUserObject. This is what must be returned by the authenticate method. In our settings.ini file, add the following settings:\n[JWT] expires_at=3600 secret_key=yti87y2XMluYnUQQShUYApqmwkezWjzn bearer_key=Bearer\rStill in the settings.ini file, let\u0026rsquo;s register our Authentication Backend:\n[authentications] jwt=application\\authentications\\JwtAuthBackend\rAdd our Login Logic In our services directory, create a new file UserService.php. In normal circumstances, you should have the UserService class already created for you. But if it\u0026rsquo;s not, you can create it in two ways. You can either create it manually or use the Pionia CLI to generate it for you.\nUsing the Pionia CLI:\nphp pionia gen:service user\rSelect Basic in the options provided by entering 1 or just hitting enter since it\u0026rsquo;s the default.\nOn the next action, you can write register,login to generate the register and login actions.\nAnd you should have the new service created for you in the services directory.\nUserService.php\rservices/ ├── UserService.php\rHowever, I created mine manually, so what I have as login will be equivalent to your loginUser and register will be equivalent to your registerUser.\nAnd add the following code:\n\u0026lt;?php namespace application\\services; use application\\authenticationBackends\\JwtUtils; use Exception; use Pionia\\Request\\BaseRestService; use Pionia\\Response\\BaseResponse; use Porm\\Porm; class UserService extends BaseRestService { /** * @throws Exception */ public function login($data): BaseResponse { $this-\u0026gt;requires([\u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;]); $username = $data[\u0026#39;username\u0026#39;]; $password = $data[\u0026#39;password\u0026#39;]; $jwtUtility = new JwtUtility(); $user = $jwtUtility::getUserByUsername($username); $checkPassword = password_verify($password, $user-\u0026gt;password); if (!$checkPassword) { throw new InvalidDataException(\u0026#34;Wrong password\u0026#34;); } $token = $jwtUtility-\u0026gt;generateToken($user); return BaseResponse::JsonResponse(0, \u0026#34;Logged in successfully\u0026#34;, [\u0026#39;token\u0026#39; =\u0026gt; $token]); } /** * @param $data * @return BaseResponse * @throws Exception */ public function register($data): BaseResponse { // user can\u0026#39;t exceed here if any of these columns are provided // in the request $this-\u0026gt;requires([\u0026#34;first_name\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;last_name\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;password\u0026#34;]); $first_name = $data[\u0026#34;first_name\u0026#34;]; $last_name = $data[\u0026#34;last_name\u0026#34;]; $email = $data[\u0026#34;email\u0026#34;]; $password = $data[\u0026#34;password\u0026#34;]; $username = $data[\u0026#34;username\u0026#34;]; // if the user does not define a role, we set it to USER. // not cool for production $role_code = $data[\u0026#34;role_code\u0026#34;] ?? \u0026#39;USER\u0026#39;; // data validation. User can\u0026#39;t pass here if the following are invalid $this-\u0026gt;asEmail($email); $this-\u0026gt;asPassword($password); $hash = password_hash($password, PASSWORD_DEFAULT); // check if the email isn\u0026#39;t taken $checkEmail = Porm::from(\u0026#34;system_user\u0026#34;)-\u0026gt;has([\u0026#39;email\u0026#39; =\u0026gt; $email]); if ($checkEmail) { throw new InvalidDataException(\u0026#34;Email already exists\u0026#34;); } // check if the username is taken $checkUsername = Porm::from(\u0026#34;system_user\u0026#34;)-\u0026gt;has([\u0026#39;username\u0026#39; =\u0026gt; $username]); if ($checkUsername) { throw new InvalidDataException(\u0026#34;Username already exists\u0026#34;); } $saved = null; // saving happens in a transaction Porm::from(\u0026#34;\u0026#34;)-\u0026gt;inTransaction(function () use ($email, $hash, $first_name, $last_name, $role_code, $username, \u0026amp;$saved) { $saved = Porm::table(\u0026#34;system_user\u0026#34;) -\u0026gt;columns([\u0026#34;email\u0026#34;, \u0026#34;first_name\u0026#34;, \u0026#34;last_name\u0026#34;, \u0026#34;role_code\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;is_active\u0026#34;, \u0026#34;last_logged_in_at\u0026#34;, \u0026#34;created_at\u0026#34;]) // we want to ignore the password field in data returned -\u0026gt;save([\u0026#34;email\u0026#34; =\u0026gt; $email, \u0026#34;password\u0026#34; =\u0026gt; $hash, \u0026#34;username\u0026#34; =\u0026gt; $username, \u0026#34;role_code\u0026#34; =\u0026gt; $role_code, \u0026#34;first_name\u0026#34; =\u0026gt; $first_name, \u0026#34;last_name\u0026#34; =\u0026gt; $last_name, \u0026#34;is_active\u0026#34; =\u0026gt; true]); // let\u0026#39;s just activate all profiles }); if (!$saved){ throw new InvalidDataException(\u0026#34;Failed to create user\u0026#34;); } return BaseResponse::JsonResponse(0, \u0026#34;User added successfully\u0026#34;, $saved); } } What do we have here? We have a UserService class that extends BaseRestService. This class has two actions: login and register. In the login action, we require the username and password fields. We then fetch the user by username and verify the password. If the password is correct, we generate a token and return it. In the register action, we require the username, password, email, first_name, and last_name fields. We set the role_code to USER if it\u0026rsquo;s not provided. We validate the email and password fields. asEmail checks if we have a valid email and asPassword checks if the password passes the minimum requirements(at least 1 special character, at least 1 capital letter, at least 1 digit, length of at least 8). We then hash the password and save the user to the database. We check if the username and email are already taken. If everything is okay, we create the user in transaction and return the user object. We define the columns that should be returned upon successful creation of the user. We return a JSON response with the user object. Registering our UserService We shall also need to register our UserService in the switch which shall handle henceforth all our requests.\nCreate a switch if it doesn\u0026rsquo;t exist in your switches directory. This can be created manually or using Pionia Cli\nUsing Pionia CLI\nphp pionia gen:switch v2\rYou must target the version the switch is targeting, the above targets version 2 which can be accessed on /api/v2/. The above command creates V2Switch.php in the switches directory.\nYou then have to register it in your routes.php file.\n\u0026lt;?php use Pionia\\Core\\Routing\\PioniaRouter; $router = new PioniaRouter(); $router-\u0026gt;addSwitchFor(\u0026#34;application\\switches\\MainApiSwitch\u0026#34;) // by default targets v1 -- /api/v1/ -\u0026gt;addSwitchFor(\u0026#34;application\\switches\\V2Switch\u0026#34;, \u0026#34;v2\u0026#34;); // that\u0026#39;s the version we are targeting -- /api/v2/ return $router-\u0026gt;getRoutes();\rUnder normal circumstances, the MainApiSwitch.php that ships with the template is enough!\nswitches/ ├── MainApiSwitch.php\rAnd add to your registerServices method in the MainApiSwitch.php file the following code:\nclass MainApiSwitch extends BaseApiServiceSwitch { /** * Register your services here. * * @return array */ public function registerServices(): array { return [ \u0026#39;user\u0026#39; =\u0026gt; UserService::class, // notice this here ]; } }\rTesting our Authentication To test our authentication, we shall use Postman. You can download Postman here.\nRegistering a User To register a user, send a POST request to http://localhost:8000/api/v1/ with the following JSON payload:\nRegister User - Response Making the above request, should return the following response.\nLogging in a User To test Login, send a POST request to http://localhost:8000/api/v1/ with the following JSON payload:\nLogin User - Response You should get a response with a token like below.\nYou can use this token to authenticate your requests.\nTesting Authentication So to test out that our authentication is working, we shall add another action called profile in our UserService.php file.\nUserService.php\r/** * @throws UserUnauthenticatedException */ public function profile(): BaseResponse { $this-\u0026gt;mustAuthenticate(); // user can\u0026#39;t pass here if they are not authenticated $user = $this-\u0026gt;auth()-\u0026gt;user; return BaseResponse::JsonResponse(0, null, $user); }\rTesting the Profile Action - request without token \u0026#34;POST\u0026#34; http://localhost:8000/api/v1/ { \u0026#34;service\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;profile\u0026#34; }\rResponse - not token { \u0026#34;returnCode\u0026#34;: 401, \u0026#34;returnMessage\u0026#34;: \u0026#34;You must be authenticated to access this resource\u0026#34;, \u0026#34;returnData\u0026#34;: null, \u0026#34;extraData\u0026#34;: null }\rNow let\u0026rsquo;s test the profile action with a token.\nTesting the Profile Action - request with token POST /api/v1/ HTTP/1.1 Host: localhost:8000 Content-Type: application/json Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJQaW9uaWEiLCJpYXQiOjE3MjIyNTQ3MjIsImV4cCI6MTcyMjI1ODMyMiwic3ViIjoiamV0MSJ9.8gzQNbPR74RqAFa6HxFhFGMv904ow2Ux5Eq_yKRcVz8 Content-Length: 50 { \u0026#34;service\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;profile\u0026#34; }\rTesting the Profile Action - request with token { \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: null, \u0026#34;returnData\u0026#34;: { \u0026#34;first_name\u0026#34;: \u0026#34;Test\u0026#34;, \u0026#34;last_name\u0026#34;: \u0026#34;User\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;$2y$10$obbGcRTCDgV31K5k2KMW8.8hkXy6Enh3K9l9JHRpgsTmfwlXVgScy\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;sample1@gmail.com\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;jet1\u0026#34;, \u0026#34;role_code\u0026#34;: \u0026#34;USER\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-07-29 10:00:39.671637\u0026#34;, \u0026#34;last_logged_in_at\u0026#34;: \u0026#34;2024-07-29 12:05:22\u0026#34;, \u0026#34;is_active\u0026#34;: true, \u0026#34;id\u0026#34;: 3 }, \u0026#34;extraData\u0026#34;: null }\rWe can remove the above password hash just to clean up further.\nIn our authentication backend, let\u0026rsquo;s change the following line highlighted and add false as the second parameter to the getUserByUsername method.\n23 public function authenticate(Request $request): ?ContextUserObject 24\t{ 25 $authorizationHeader = $request-\u0026gt;headers-\u0026gt;get(\u0026#34;Authorization\u0026#34;); 26 27 if (!$authorizationHeader){ 28 return null; 29 } 30 31 $jwtUtility = new JwtUtility(); 32 $bearerKey = $jwtUtility-\u0026gt;jwtSettings()[\u0026#39;bearer_key\u0026#39;] ?? \u0026#39;Bearer\u0026#39;; 33 34 // check if our token starts with the above key 35 if (!str_starts_with($authorizationHeader, $bearerKey)){ 36 return null; 37 } 38 // grab the token alone removing the \u0026#34;Bearer \u0026#34; part 39 $token = trim(str_replace($bearerKey, \u0026#39;\u0026#39;, $authorizationHeader)); 40 41 $decoded = $jwtUtility-\u0026gt;decodeToken($token); 42 43 $username = $decoded-\u0026gt;sub; 44 45 $user = $jwtUtility::getUserByUsername($username, false); 46 // since we have our context user, we can populate them from here 47 $contextUser = new ContextUserObject(); 48 $contextUser-\u0026gt;user = $user; 49 $contextUser-\u0026gt;authenticated = true; 50 $contextUser-\u0026gt;authExtra[\u0026#34;role\u0026#34;] = $user-\u0026gt;role_code; 51 // we have no permissions, so we ignore the permissions key 52 return $contextUser; 53\t}\rConclusion This is a simple way to create an authentication system using JWT in Pionia. You can extend this to include more features like password reset, email verification, etc. You can also use other JWT libraries like lcobucci/jwt or spomky-labs/jose if you prefer.\nRemember to always hash your passwords before saving them to the database. You can use the password_hash function in PHP.\n", "date": "2024-06-29", "id": 19, "permalink": "/documentation/security/example-jwt-authentication/", "summary": "This section guides us through Pionia\u0026rsquo;s approach to authentication using JWT. Firebase/JWT package is used for illustration.", "tags": [], "title": "Example - JWT Authentication" },
  { "content": "\rThis section assumes you have already set up your project and have already gone through the Api Tutorial guide atleast.\nIntroduction Pionia uses PORM to interact with the database. Porm is a simple and lightweight QueryBuilder that is built on top of the medoo framework. Porm provides a set of tools and conventions that make it easy to interact with the database in PHP. PORM is designed to be simple, lightweight, and easy to use.\nInstallation If you want to check out PORM alone or want to use it outside the Pionia framework, you can install it via composer.\ncomposer require pionia/porm\rIf you are using Pionia, you do not need to install PORM separately. PORM is already included in the Pionia framework.\nConfiguration Configuring PORM is simple. All you need is the settings.ini file in the root of your project. The settings.ini file should contain the following:\n[db] database = username = type = host = password = port =\rSupported Databases Postgres (PostgreSQL) via the pgsql driver MySQL/MariaDB via the mysql driver Oracle via the oci driver Sybase via the dblib driver MSSQL via the sqlsrv or dblib driver SQLite via the sqlite driver Please remember to install the necessary PHP extensions for the database you are using in order to connect to the database. This usually happens in the php.ini file.\nIf you are using Pionia, you do not need to configure PORM separately. PORM is already configured in the Pionia framework.\nMultiple Database Connections If you want to connect to multiple databases, you can do so by adding the database connection settings to the settings.ini file. You can then specify the database connection to use when querying the database.\n; other settings [db] database = username = type = host = password = port = [db2] database = username = type = host = password = port = ; other settings\rYou can then specify the database connection to use when querying the database.\nuse Porm\\Porm; Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;using(\u0026#39;db2\u0026#39;); // will connect to the db2 database By default, PORM will use the default database connection(db) to query the database.\nAccessing the Underlying Medoo Instance If you need to access the underlying Medoo instance, you can do so by calling the getDatabase method on the Porm class.\nuse Porm\\Porm; $instance = Porm::from(\u0026#39;posts\u0026#39;); //other queries here $database = $instance-\u0026gt;database; // returns the Medoo instance // this is also similar to $database = $instance-\u0026gt;getDatabase(); // returns the Medoo instance The $database variable will contain the Medoo instance, which you can use to interact with the database directly availing every method medoo provides.\nGetting the last inserted ID To get the last inserted ID after inserting a record into the database, you can call the lastId method on the Porm class.\nuse Porm\\Porm; $instance = Porm::from(\u0026#39;posts\u0026#39;); $instance-\u0026gt;save([ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;My Post\u0026#39;, \u0026#39;content\u0026#39; =\u0026gt; \u0026#39;This is my post content\u0026#39; ]); // other queries here $lastId = $instance-\u0026gt;lastId();\rThe $lastId variable will contain the last inserted ID.\nUsage PORM does not rely on models to interact with the database. Instead, you get to interact with the database directly. This comes with a lot of flexibility and simplicity. Porm also interacts with both new and existing databases.\nAll Queries originate from the Porm instance. Here is an example of how to interact with the database using PORM.\nDetermining the target table All queries start by determining the target table. This is done by calling the from method on the Porm instance. The from method takes the table name as the first argument. The table name must match the table name in the database.\nuse Porm\\Porm; Porm::from(\u0026#39;posts\u0026#39;);\rYou can also alias the table name by passing the alias as the second argument.\nuse Porm\\Porm; Porm::from(\u0026#39;posts\u0026#39;, \u0026#39;p\u0026#39;);\rAs of v1.0.2, You can achieve the above using the table method. This method is exactly the same as the from method however it is more readable.\nuse Porm\\Porm; Porm::table(\u0026#39;posts\u0026#39;, \u0026#39;p\u0026#39;);\rYou can also define the connection to use at this point.\nuse Porm\\Porm; # will connect to the db2 database Porm::from(\u0026#39;posts\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;db2\u0026#39;); # or Porm::table(\u0026#39;posts\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;db2\u0026#39;);\rDefining the columns To select specific columns from the table, you can use the columns method. This method should be called on the Porm instance.\nuse Porm\\Porm; Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;columns(\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;); # or Porm::table(\u0026#39;posts\u0026#39;)-\u0026gt;columns([\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;]);\rThis can used whether getting one or multiple records.\n", "date": "0001-01-01", "id": 20, "permalink": "/documentation/database/configuration-getting-started/", "summary": "This section assumes you have already set up your project and have already gone through the Api Tutorial guide atleast.", "tags": [], "title": "Configuration - Getting Started" },
  { "content": "\rThis section assumes you have alredy completed configuring the database from the Configuration Section.\nIntroduction Under this section, we will look at how to make queries to the database using the PORM - Pionia ORM. Queries are used to interact with the database and retrieve data. PORM provides a set of tools and conventions that make it easy to interact with the database in PHP.\nRetrieving Data You can retrieve a single item from the database or multiple items at ago. In Porm, not all methods query the database. Some methods are used to build the query and return the query object.\nRetrieving a Single Item To retrieve a single item from the database, you can use the get method. This method returns an object or NULL if no matching record is found.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;get(1); // select * from users where id = 1 If the an integer or string is provided for the get method, it is assumed to be the primary key of the table. If an array is provided, it is assumed to be the where clause.\nYou can also provide an integer or string and determine the column name to use as the primary key.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;get(1, \u0026#39;user_id\u0026#39;); // select * from users where user_id = 1 Conditions can also be provided as an array. The array should contain the column name as the key and the value as the value. This is one way of building a where clause.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;get([\u0026#39;user_id\u0026#39; =\u0026gt; 1, \u0026#39;age\u0026#39; =\u0026gt; 10]); // select * from users where user_id = 1 and age = 10 All array conditions passed to the get method are joined by AND.\n$data will contain the object or NULL if no matching record is found.\nThe get method queries the database. So you should always call the get method last.\nFetching multiple records To fetch all data from the table, you can use the all method. This method, just like the get method, can take up array conditions and also queries the database. Therefore, you should always call the all method last.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;all(); var_dump($data); // array of data You can also specify the columns to fetch by using the columns method. This is useful when you only need specific columns from the table and can be used before all methods that query the database.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;columns(\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;)-\u0026gt;all(); var_dump($data); // array of data You can filter the data by providing the array of conditions to the all method just like we did with the get method.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;all([\u0026#39;id\u0026#39; =\u0026gt; 1]); // select * from posts where id = 1 var_dump($data); // array of data The all method unlike the get method, returns an array of data or an empty array if no matching record is found.\nRandom Records To get random data from the table, you can use the random method. The random method takes the number of results to return as the first argument.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;random(10); var_dump($data); // array of data You can also pass an array of conditions to the random method.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;random(10, [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Pionia\u0026#39;]); var_dump($data); // array of data To get just one random item, you can pass 1 or ignore the length.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;random(); var_dump($data); // object of data The random method queries the database. So you should always call the random method last. Also, if you query one item, random will return an object, but if you define length greater than one, it will return an array.\nInserting Data To insert data into the table, you can use the save method. The save method takes an array of data to insert into the table and returns the saved object.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;save([\u0026#39;title\u0026#39; =\u0026gt; \u0026#39;Hello\u0026#39;, \u0026#39;content\u0026#39; =\u0026gt; \u0026#39;World\u0026#39;]); var_dump($data); // the saved object The save method hits the database. So you should always call the save method last.\nUpdating Data To update data in the table, you can use the update method. The update method takes an array of data to update in the table and the condition to filter the data on.\nThis method returns a PDOStatement object. You can get the number of rows affected by calling the rowCount method on the returned object.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;) -\u0026gt;update([\u0026#39;title\u0026#39; =\u0026gt; \u0026#39;Hello\u0026#39;, \u0026#39;content\u0026#39; =\u0026gt; \u0026#39;World\u0026#39;], [\u0026#39;id\u0026#39; =\u0026gt; 1]); // update posts set title = \u0026#39;Hello\u0026#39;, content = \u0026#39;World\u0026#39; where id = 1 var_dump($data-\u0026gt;rowCount()); // the number of rows affected The update method hits the database. So you should always call the update method last.\nDeleting Data To delete data from the table, you can use the delete method. The delete method takes the condition to filter the data on.\nThis method returns a PDOStatement object. You can get the number of rows affected by calling the rowCount method on the returned object.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;delete([\u0026#39;id\u0026#39; =\u0026gt; 1]); var_dump($data-\u0026gt;rowCount()); // the number of rows affected This method can also be used to delete all data from the table that matches the condition. Passing an empty array will delete all data from the table.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;deleteAll([]); var_dump($data-\u0026gt;rowCount()); // the number of rows affected The two methods delete and deleteAll do exactly the same thing. deleteAll is just an alias for delete.\nYou can also delete data based on the primary key id.\nuse Porm\\Porm; $id = 2 $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;deleteById($id); // delete from posts where id = 2 var_dump($data-\u0026gt;rowCount());\rHas Data To check if data exists in the table, you can use the has method. The has method takes the condition to filter the data on.\nThis method returns a boolean value.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;has([\u0026#39;id\u0026#39; =\u0026gt; 1]); var_dump($data); // true or false The has method queries the database. So you should always call the has method last.\nPassing a string to has queries the database for the primary key id.\nuse Porm\\Porm; $id = \u0026#39;123\u0026#39; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;has($id); var_dump($data); // true or false Raw Queries Before we dive into complex database querying, Let\u0026rsquo;s first look at a basic raw query mechanism that porm presents to us. This can be handy especially when you think that the query you need, is not supported by porm by default. However, overusing this feature can somehow mean you are not using porm well.\nuse Porm\\Porm; $data = Porm::rawQuery(\u0026#39;select * from posts where id = 1\u0026#39;);\rIf the $data above comprises one item, then the result will be an object. If it comprises of multiple items, then the result will be an array.\nYou can also pass conditions to the rawQuery method.\nuse Porm\\Porm; $data = Porm::rawQuery(\u0026#39;select * from posts where id = :id\u0026#39;, [\u0026#39;id\u0026#39; =\u0026gt; 1]);\r", "date": "0001-01-01", "id": 21, "permalink": "/documentation/database/making-queries/", "summary": "This section assumes you have alredy completed configuring the database from the Configuration Section.", "tags": [], "title": "Making Queries" },
  { "content": "\rThis section assumes you have alredy completed configuring the database from the Configuration Section.\nAlso, for basic knowledge and understanding, please first look at the Making Queries Section\nIntroduction Sometimes, you need more than just fetching data from the database. You may need to filter the data based on certain conditions. This is where filtering comes in. Filtering allows you to specify conditions that the data must meet before it is returned.\nIn this section, we will look at how to filter data when querying the database using PORM.\nwhere This method can be used to filter data based on a single \u0026lsquo;AND\u0026rsquo; condition. This method can be used with all the other methods in the query builder.\n$users = Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;where([\u0026#39;age\u0026#39; =\u0026gt; 10])-\u0026gt;get();\rYou can chain as many where methods as you want to filter the data.\n$users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;where([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;where([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;all();\rAll conditions in the where method are joined by an \u0026lsquo;AND\u0026rsquo; operator.\nfilter The filter method can be used to filter data based on multiple conditions. The conditions are joined by an \u0026lsquo;AND\u0026rsquo; operator.\n$users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;filter([\u0026#39;age\u0026#39; =\u0026gt; 10, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;all();\rThis might look familiar, however, the filter method ports us to the underlying QueryBuilder class, which allows us to chain more complex conditions and avails more methods.\nUsing filter, you can access methods such as orderBy, group, limit, match, having, first, get, all and many more.\n$users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;filter([\u0026#39;age\u0026#39; =\u0026gt; 10, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;orderBy([\u0026#39;age\u0026#39; =\u0026gt; \u0026#39;DESC\u0026#39;]) -\u0026gt;limit(10) -\u0026gt;startAt(5) -\u0026gt;all();\rWhere Builder Observing all our examples provided so far, we can notice that where conditions are passed as an array. With this builder, you can build a more complex query which will internally be converted to an array as shown in the examples above.\nBulding To start building, you need to first call the builder method on the Where class.\n$clause= Where::builder();\rFrom there, you can chain methods to build your query.\nThe builder MUST finally call the build method to actually build the query.\n$clause = Where::builder() // add here both AND and OR conditions -\u0026gt;build();\rYou can then pass this clause to any method that accepts conditions.\n$clause = Where::builder() // add here both AND and OR conditions -\u0026gt;build(); $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;where($clause) // with where method -\u0026gt;all(); $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;filter($clause) // with filter method -\u0026gt;all(); $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;all($clause); // with all method $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;first($clause); // with first method $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;filter($clause) // with filter method that also defines more complex queries -\u0026gt;orderBy([\u0026#39;age\u0026#39; =\u0026gt; \u0026#39;DESC\u0026#39;]) -\u0026gt;limit(10) -\u0026gt;startAt(5) -\u0026gt;all();\rAND Conditions To add an \u0026lsquo;AND\u0026rsquo; condition, you can use the and method.\n$clause = Where::builder() -\u0026gt;and([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;and([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;build();\rYou can chain as many and methods as you want to add more conditions.\nOR Conditions To add an \u0026lsquo;OR\u0026rsquo; condition, you can use the or method.\n$clause = Where::builder() -\u0026gt;or([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;or([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;build();\rYou can chain as many or methods as you want to add more conditions.\nThe \u0026ldquo;and()\u0026rdquo; and \u0026ldquo;or()\u0026rdquo; methods can be used together to build more complex queries.\nAlso note that the \u0026ldquo;and()\u0026rdquo; and \u0026ldquo;or()\u0026rdquo; methods take in an array of conditions. Which means you can pass a full clause to them too!\nThis is how you start to build more complex conditions!\nAND and OR You can mix \u0026lsquo;AND\u0026rsquo; and \u0026lsquo;OR\u0026rsquo; conditions to build more complex queries.\n$clause = Where::builder() -\u0026gt;and([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;or([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;build();\rYou can chain as many and and or methods as you want to build more complex queries.\nComplex Relativity You can also build more complex queries by nesting conditions.\n$clause = Where::builder() -\u0026gt;and([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;or( Where::builder() -\u0026gt;and([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;or([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Jane Doe\u0026#39;]) -\u0026gt;and([\u0026#39;age\u0026#39; =\u0026gt; 20]) -\u0026gt;build() ) -\u0026gt;build(); // where age = 10 OR (name = \u0026#39;John Doe\u0026#39; OR name = \u0026#39;Jane Doe\u0026#39; AND age = 20) You can nest as many conditions as you want to build more complex queries. This is where Porm shines!\n", "date": "0001-01-01", "id": 22, "permalink": "/documentation/database/queries-with-filtering/", "summary": "This section assumes you have alredy completed configuring the database from the Configuration Section.", "tags": [], "title": "Queries with Filtering" },
  { "content": "\rThis section assumes you have alredy completed configuring the database from the Configuration Section.\nIntroduction From v1.0.6 of Porm, you can now query relationships directly. If you\u0026rsquo;re using our generic services, most of this has already been taken care of for you. However,if you\u0026rsquo;re the kind that loves control or less magic, you can read ahead to see how you can query relationships directly.\nSupported Relationships Porm supports the following joins:\nInner Join Left Join Right Join Full Join Teleporting to the join verse. If you haven\u0026rsquo;t noticed it, in Porm, when you call the filter method, you teleport to the advanced filtering universe. The same way, when you call the join method, you teleport to the join universe.\nLet\u0026rsquo;s start with an example. Imagine we have two tables, products and categories. The products table has a category_id column that relates to the id column in the categories table.\nExample\rPorm::from(\u0026#34;products\u0026#34;) -\u0026gt;join() -\u0026gt;inner(\u0026#34;categories\u0026#34;, \u0026#34;products.category_id = categories.id\u0026#34;) -\u0026gt;all();\r", "date": "0001-01-01", "id": 23, "permalink": "/documentation/database/relationships/", "summary": "Pionia QueryBuilder supports querying relationships. This is a powerful feature that allows you to query data across multiple tables.", "tags": [], "title": "Relationships" },
  { "content": "\rThis section assumes you have alredy completed configuring the database from the Configuration Section.\nAlso, for basic knowledge and understanding, please first look at the Making Queries Section\nIntroduction This section covers database functions that can be used to aggregate data in the database. Aggregation functions are used to perform calculations on the data in the database. These functions can be used to calculate the sum, average, minimum, maximum, and count of the data in the database.\nInbuilt Aggregation Functions Some common aggregation functions have already been implemented in PORM. These functions can be used to perform calculations on the data in the database directly.\ncount The count function is used to count the number of records in the database. This function can be used to count the number of records in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;count(); // select count(*) from users You can also provide a column name to count the number of records in the database that have a value in the specified column.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;count(\u0026#39;age\u0026#39;); // select count(age) from users You can also provide conditions to count the number of records in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;count(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select count(*) from users where age = 10 The count function returns the number of records in the database that meet the specified conditions.\nsum The sum function is used to calculate the sum of the values in a column in the database. This function can be used to calculate the sum of the values in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;sum(\u0026#39;age\u0026#39;); // select sum(age) from users You can also provide conditions to calculate the sum of the values in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;sum(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select sum(age) from users where age = 10 The sum function returns the sum of the values in the column in the database that meet the specified conditions.\nAll methods that take in a condition can be called after the \u0026ldquo;where\u0026rdquo; method. This is because the \u0026ldquo;where\u0026rdquo; method is used to build the where clause for the query.\navg The avg function is used to calculate the average of the values in a column in the database. This function can be used to calculate the average of the values in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;avg(\u0026#39;age\u0026#39;); // select avg(age) from users You can also provide conditions to calculate the average of the values in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;avg(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select avg(age) from users where age = 10 The avg function returns the average of the values in the column in the database that meet the specified conditions.\nmax The max function is used to calculate the maximum value in a column in the database. This function can be used to calculate the maximum value in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;max(\u0026#39;age\u0026#39;); // select max(age) from users You can also provide conditions to calculate the maximum value in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;max(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select max(age) from users where age = 10 The max function returns the maximum value in the column in the database that meet the specified conditions.\nmin The min function is used to calculate the minimum value in a column in the database. This function can be used to calculate the minimum value in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;min(\u0026#39;age\u0026#39;); // select min(age) from users You can also provide conditions to calculate the minimum value in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;min(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select min(age) from users where age = 10 The min function returns the minimum value in the column in the database that meet the specified conditions.\nAll the above methods query the database and return the result. Therefore, you should always call these methods last.\nUsing the Agg Builder We have also put aside a builder class that can be used to build more complex aggregation queries. The Agg builder comes with a number of methods to cover your aggregation needs.\nInitializing the Agg Builder To initialize the Agg builder, you can use the builder method.\nYou must finally call the build method to get the actually build your generated aggregates.\nuse Porm\\database\\aggregation\\Agg; $agg = Agg::builder() // add here your aggregation functions -\u0026gt;build();\rAgg builder comes with a number of methods that can be used to build the aggregation query. They include\nrandom use Porm\\database\\aggregation\\Agg; $agg = Agg::builder() -\u0026gt;random(\u0026#39;name\u0026#39;, \u0026#39;names\u0026#39;) // rand(names) as names -\u0026gt;build();\ravg use Porm\\database\\aggregation\\Agg; $agg = Agg::builder() -\u0026gt;avg(\u0026#39;age\u0026#39;, \u0026#39;average_age\u0026#39;) // avg(age) as average_age -\u0026gt;build();\rcompare Compare the value of two columns in the database. In comparison we use operators like =, \u0026gt;, \u0026lt;, !=.\nuse Porm\\database\\aggregation\\Agg; $agg = Agg::builder() -\u0026gt;columnsCompare(\u0026#39;price\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;10\u0026#39;) // age \u0026gt; 10 -\u0026gt;build();\rlike Used to add a like condition to a query\n$user = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;get(Agg::builder() -\u0026gt;like(\u0026#39;title\u0026#39;, $name) -\u0026gt;build() ); // select * from todos where title like \u0026#39;%$name%\u0026#39; notLike Used to add a not like condition to a query\n$user = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;get(Agg::builder() -\u0026gt;notLike(\u0026#39;title\u0026#39;, $name) -\u0026gt;build() ); // select * from todos where title not like \u0026#39;%$name%\u0026#39; div Used to divide a column by a certain value in the database\n$user = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;get(Agg::builder() -\u0026gt;div(\u0026#39;total\u0026#39;, 5) -\u0026gt;build() ); // select total/5 from todos between Adds a between check on a column. It checks if the value of the given column is between two given points.\n$results = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder() -\u0026gt;between(\u0026#39;id\u0026#39;, [1, 10]) -\u0026gt;build() )-\u0026gt;all(); // select * from todos where id between 1 and 10 notBetween Checks if the value of the given column is not between the given points.\n$results = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder() -\u0026gt;notBetween(\u0026#39;id\u0026#39;, [1, 10]) -\u0026gt;build() )-\u0026gt;all();\rjsonified Jsonify the given value and assigns it to the given column.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;jsonified(\u0026#39;someAlias\u0026#39;, [\u0026#39;x\u0026#39;=\u0026gt;1, \u0026#39;y\u0026#39;=\u0026gt;5]) -\u0026gt;build() )-\u0026gt;all(); // select JSON(\u0026#39;x\u0026#39;, 1, \u0026#39;y\u0026#39;, 5) as someAlias from todos of Multiplies a column by a certain value in the database\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;of(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias*10 from todos minus Subtracts a column by a certain value in the database\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;minus(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias-10 from todos plus Adds a column by a certain value in the database\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;plus(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias+10 from todos eq Opposite of eq. Checks if the value of the given column is equal to the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;eq(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias=10 from todos neq Opposite of eq. Checks if the value of the given is not equal to the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;neq(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias!=10 from todos now Assigns the current timestamp to the given alias or column.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;update(Agg::builder()-\u0026gt;now(\u0026#34;updated_at\u0026#34;)-\u0026gt;build(), 1); // update todos set updated_at = now() where id =1 lt Check if the column value is less than the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder()-\u0026gt;lt(\u0026#39;age\u0026#39;, 20)-\u0026gt;build()) -\u0026gt;all();\rlte Checks if the column value is less than or equal to the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder()-\u0026gt;lte(\u0026#39;age\u0026#39;, 20)-\u0026gt;build()) -\u0026gt;all();\rgt Checks if the column value is greater than the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder()-\u0026gt;gt(\u0026#39;age\u0026#39;, 20)-\u0026gt;build()) -\u0026gt;all();\rgte Checks if the column value is greater than or equal the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder()-\u0026gt;gte(\u0026#39;age\u0026#39;, 20)-\u0026gt;build()) -\u0026gt;all();\ruuid This can be used in two ways. The first way is where a uuid is provided and the other way is where you want to sign a unique random uuid to a column.\n$agg = Agg::builder()-\u0026gt;uuid(\u0026#39;code\u0026#39;)-\u0026gt;build() // code = uuid() // or with an existing one. $agg = Agg::builder()-\u0026gt;uuid(\u0026#39;code\u0026#39;, $myCoolUuid)-\u0026gt;build() // code = \u0026#39;$myCoolUuid\u0026#39; max() Gets the maximum value of the given column and assigns it to the given alias\n$agg = Agg::builder()-\u0026gt;max(\u0026#39;maxAge\u0026#39;, \u0026#39;age\u0026#39;)-\u0026gt;build() // MAX(age) as maxAge min() Gets the minimum value of the given column and assigns it to the given alias\n$agg = Agg::builder()-\u0026gt;min(\u0026#39;maxAge\u0026#39;, \u0026#39;age\u0026#39;)-\u0026gt;build() // MIN(age) as maxAge sum() Gets the sum of the given column and assigns it to the given alias.\n$agg = Agg::builder()-\u0026gt;sum(\u0026#39;maxAge\u0026#39;, \u0026#39;age\u0026#39;)-\u0026gt;build() // SUM(age) as maxAge regex If all above don\u0026rsquo;t work for you, you can use this aggregation function to provide your own regular expression that the db should check against.\n$agg = Agg::builder()-\u0026gt;regex(\u0026#39;name\u0026#39;, \u0026#39;^d\u0026#39;)-\u0026gt;build() // name ~ \u0026#39;^d\u0026#39; Chaining multiple You can chain as many aggregations as you with till you call the build() method.\n$agg = Agg::builder() -\u0026gt;regex(\u0026#39;name\u0026#39;, \u0026#39;^d\u0026#39;) -\u0026gt;gte(\u0026#39;age\u0026#39;, 10) -\u0026gt;build(); // name ~ \u0026#39;^d\u0026#39; and age \u0026gt;= 10 ", "date": "0001-01-01", "id": 24, "permalink": "/documentation/database/using-functions-aggregation/", "summary": "This section assumes you have alredy completed configuring the database from the Configuration Section.", "tags": [], "title": "Using Functions - Aggregation" },
  { "content": "", "date": "2023-09-07", "id": 25, "permalink": "/docs/moonlight/", "summary": "This section guides how moonlight removes the unnecessary complexity from APIs and makes it easy to build REST Applications in any language based on the Pionia.", "tags": [], "title": "Moonlight Architecture" },
  { "content": "Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ", "date": "2023-09-07", "id": 26, "permalink": "/reference/example-reference/", "summary": "Reference pages are ideal for outlining how things work in terse and clear terms.", "tags": [], "title": "Example Reference" },
  { "content": "We shall be updating this page with resources that will help you enhance your Pionia Framework journey.\n", "date": "2024-02-27", "id": 27, "permalink": "/resources/", "summary": "We shall be updating this page with resources that will help you enhance your Pionia Framework journey.", "tags": [], "title": "Resources" },
  { "content": "", "date": "2023-09-07", "id": 28, "permalink": "/docs/", "summary": "", "tags": [], "title": "Docs" },
  { "content": "At its core, Pionia uses the Monolog library to handle logging.\nInitialization Logging is inbuilt in Pionia. To view the logs in real-time, you can run the following command in a different terminal window pointing to your log file, which is by default server.log:\ntail -f server.log # replace server.log with your log file\rUsage Anywhere in your app, just call the logger constant to log messages. The following log levels are available:\npublic function getItem(): ?object { logger-\u0026gt;info(\u0026#34;Getting item\u0026#34;); logger-\u0026gt;debug(\u0026#34;Getting item\u0026#34;); logger-\u0026gt;critical(\u0026#34;Getting item\u0026#34;); logger-\u0026gt;error(\u0026#34;Getting item\u0026#34;); logger-\u0026gt;warning(\u0026#34;Getting item\u0026#34;); logger-\u0026gt;notice(\u0026#34;Getting item\u0026#34;); logger-\u0026gt;alert(\u0026#34;Getting item\u0026#34;); logger-\u0026gt;emergency(\u0026#34;Getting item\u0026#34;); $data = $this-\u0026gt;request-\u0026gt;getData(); $this-\u0026gt;requires([$this-\u0026gt;pk_field]); $id = $data[$this-\u0026gt;pk_field]; $item = Porm::from($this-\u0026gt;table)-\u0026gt;columns($this-\u0026gt;listColumns)-\u0026gt;get($id); logger-\u0026gt;info(\u0026#34;Gotten item\u0026#34;); return $item; }\rThe above code will log messages at different levels. You can then view the logs in the server.log file.\n[2024-07-08T15:29:28.809573+00:00] pionia.INFO \u0026gt;\u0026gt; Getting item :: [2024-07-08T15:29:28.809623+00:00] pionia.DEBUG \u0026gt;\u0026gt; Getting item :: [2024-07-08T15:29:28.809654+00:00] pionia.CRITICAL \u0026gt;\u0026gt; Getting item :: [2024-07-08T15:29:28.809680+00:00] pionia.ERROR \u0026gt;\u0026gt; Getting item :: [2024-07-08T15:29:28.809706+00:00] pionia.WARNING \u0026gt;\u0026gt; Getting item :: [2024-07-08T15:29:28.809728+00:00] pionia.NOTICE \u0026gt;\u0026gt; Getting item :: [2024-07-08T15:29:28.809751+00:00] pionia.ALERT \u0026gt;\u0026gt; Getting item :: [2024-07-08T15:29:28.809773+00:00] pionia.EMERGENCY \u0026gt;\u0026gt; Getting item :: [2024-07-08T15:29:28.811627+00:00] pionia.INFO \u0026gt;\u0026gt; Gotten item ::\rCustomization Log File You can change the file to log to by defining the log destination in the settings.ini file:\n[SERVER] LOG_DESTINATION=server.log\rIf you want to log to php://stdout, you can define the log destination as stdout.\n[SERVER] LOG_DESTINATION=stdout\rLog Format You can also change the log format by defining the log format in the settings.ini file:\n[SERVER] LOG_FORMAT=TEXT\rLog formats can be TEXT or JSON.\nLogging Settings You can define the sections of settings.ini you want to log along:\n[LOGGER] LOGGED_SETTINGS=db,SERVER\rSecuring Log Entries You can hide sensitive information from the logs by defining the sensitive fields in the settings.ini file:\nHIDE_IN_LOGS=password,pin,acc\rThe above means that whenever a log entry contains any of the fields password, pin, or acc, the value will be replaced with *******.\nYou can also define the string to replace the sensitive fields with:\nHIDE_SUB=**********\rTurning off logs You can simply turn off DEBUG mode in the settings.ini file:\n[SERVER] DEBUG=false\rHowever much this is okay, but sometimes, if not most times, we would want to leave the logs on even when we are not in DEBUG mode.\nThe following settings can be defined in the settings.ini file:\nLogging Requests You can log requests by defining the LOG_REQUESTS setting in the settings.ini file:\n[SERVER] LOG_REQUESTS=true\rWhether in DEBUG or not, if the above is turned on, all requests will be logged. By default, this attempts to log both the requests and responses. However, Responses are sometimes heavy and you may choose to omit them. You can do so by defining the LOG_RESPONSES setting in the settings.ini file:\n[SERVER] LOG_RESPONSES=false\rAlso, defining the LOG_RESPONSES setting as true will log only the responses without the requests.\nWith version 1.1.4, you can also define which Monolog processors you would like to include.\nYou can achieve this by defining the LOG_PROCESSORS setting in the settings.ini file:\n[SERVER] LOG_PROCESSORS=Monolog\\Processor\\ProcessIdProcessor, Monolog\\Processor\\MemoryUsageProcessor\rBy default, no processor is added to the logger.\nWith the above, you app now logs the process id and memory usage in the logs.\nRenaming the logs. By default, all logs indicate the pionia prefix. You can change this by defining the APP_NAME setting in the settings.ini file:\n[SERVER] APP_NAME=blog\rThe above will change the prefix to blog.\nLog Rotation Pionia avoids dictating how you should handle log rotation. You can use the logrotate utility to rotate logs. Here is an example configuration for log rotation:\n/path/to/your/log/file { daily rotate 7 compress delaycompress missingok notifempty create }\rThere is a cool article about handling log rotation here.\nThat\u0026rsquo;s it! You now know how to log in Pionia.\n", "date": "2024-06-29", "id": 29, "permalink": "/documentation/logging-in-pionia/", "summary": "As a developer, you need to log information about the application\u0026rsquo;s state, errors, and other important information. This guide will show you how to log in pionia.", "tags": [], "title": "Logging in Pionia" },
  { "content": "", "date": "0001-01-01", "id": 30, "permalink": "/docs/documentation/database/", "summary": "", "tags": [], "title": "Database" },
  { "content": "Coming soon! ", "date": "2024-10-07", "id": 31, "permalink": "/documentation/commands-pionia-cli/", "summary": "Avails the availble commands in our Pionia CLI and how you can your custom commands.", "tags": [], "title": "Commands( Pionia CLI)" },
  { "content": "Background. Caching in Pionia is highly necessary and this guide will help us to understand the \u0026ldquo;why\u0026rdquo; and \u0026ldquo;how\u0026rdquo;.\nPionia uses a single endpoint architecture, this therefore means that all requests come via a single http verb \u0026ldquo;POST\u0026rdquo;, however, POST requests are never cached anywhere, that is, on the server or in the browsers. This is attributed to the fact that traditional browsers and servers have been made in a way that POST requests are only used to CREATE resources on the server.\nHowever, Pionia uses POST verb for get too! Since all requests are coming through one window(endpoint), we cannot be switching verbs at that point, at least, this is not supported yet.\nPionia Caching at a glance! Pionia caching is not a hard concept. Since the entire caching is just a wrapper on top of the Symfony caching mechanism. All Caching adaptors supported by symfony are also supported here. By default, FilesystemAdapter is active by default. However, when going to production, however much this might even satisfy your basic needs, we recommend stronger, reliable and faster adaptors like Memcached or Redis.\n", "date": "2024-10-07", "id": 32, "permalink": "/documentation/caching-in-pionia/", "summary": "Pionia requests are all POST however, POST requests are not cached yet some may be getting data, this guides shows us how to cache requests.", "tags": [], "title": "Caching in Pionia" },
  { "content": "Coming soon! ", "date": "2024-10-07", "id": 33, "permalink": "/documentation/pionia-helpers/", "summary": "Helpers assist in quickly accessing parts of our application without implicitly creating instances.", "tags": [], "title": "Pionia Helpers" },
  { "content": "License MIT License\nCopyright (c) 2020-2024 Pionia\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u0026ldquo;Software\u0026rdquo;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \u0026ldquo;AS IS\u0026rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", "date": "2023-09-07", "id": 34, "permalink": "/license/", "summary": "License MIT License\nCopyright (c) 2020-2024 Pionia\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u0026ldquo;Software\u0026rdquo;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:", "tags": [], "title": "License" },
  { "content": "Privacy Policy ", "date": "2023-09-07", "id": 35, "permalink": "/privacy/", "summary": "Privacy Policy ", "tags": [], "title": "Privacy Policy" },
  { "content": "\rcomposer create-project pionia/pionia-app my_beautiful_project #replace my_beautiful_project with your project name\rPionia Framework Pionia is the first PHP Rest Framework that is truly RESTful. It is designed to be simple, lightweight, and easy to use. Pionia is built on top of the Moonlight architecture, which is a powerful architecture for powering highly scaling REST projects. Pionia provides a set of tools and conventions that make it easy to build RESTful APIs in PHP.\nWhy Pionia? ", "date": "2023-09-07", "id": 36, "permalink": "/", "summary": "composer create-project pionia/pionia-app my_beautiful_project #replace my_beautiful_project with your project name\rPionia Framework Pionia is the first PHP Rest Framework that is truly RESTful.", "tags": [], "title": "Pionia Framework" },
  { "content": "", "date": "0001-01-01", "id": 37, "permalink": "/categories/", "summary": "", "tags": [], "title": "Categories" },
  { "content": "", "date": "0001-01-01", "id": 38, "permalink": "/contributors/", "summary": "", "tags": [], "title": "Contributors" },
  { "content": "", "date": "0001-01-01", "id": 39, "permalink": "/tags/", "summary": "", "tags": [], "title": "Tags" }
]
